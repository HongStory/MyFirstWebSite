<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part7</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network </a></li>
            <li><a href="page_network2.html"> NW part2 </a></li>
            <li><a href="page_network3.html"> NW part3 </a></li>
            <li><a href="page_network4.html"> NW part4 </a></li>
            <li><a href="page_network5.html"> NW part5 </a></li>
            <li><a href="page_network6.html"> NW part6 </a></li>
            <li><a href="page_network7.html"> NW part7 </a></li>
            <li><a href="page_network8.html"> NW part8 </a></li>
            <li><a href="page_network9.html"> NW part9 </a></li>
            <li><a href="page_network10.html"> NW part10 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Network part7</h2>
            <ul>
            <h4>TCP의 오류:흐름,혼잡제어</h4>    
                <li>TCP의 기능:재전송을 기반으로<br> 
                    다양한 오류를 제어,흐름 제어를<br> 
                    통해 처리할 수 있을 만큼의<br> 
                    데이터 송수신,혼잡 제어를 통해<br> 
                    네트워크가 혼잡한 정도에<br> 
                    따라 전송량 조절</li>
            <h4>재전송 기반의 오류 제어</h4>    
                <li>오류 검출과 재전송</li>    
                <li>TCP세그먼트의 체크섬 필드,충분할까?</li>
                <li>TCP가 신뢰성을 제대로 보장하려면?</li>
                <li>송신 호스트가 송신한 세그먼트에<br> 
                    문제가 발생했음을 인지할수 있어야</li>
                <li>오류를 감지하게 되면 해당<br>
                    세그먼트를 재전송할 수 있어야</li>
                <li>그렇다면 TCP는 언제 오류를<br> 
                    검출하고 재전송할까?</li>
                <li>중복된ACK세그먼트를 수신했을때</li>
                <li>타임아웃이 발생했을때</li>
                <li>호스트가 세그먼트를 전송할<br> 
                    때마다 재전송 타이머 시작</li>
                <li>타임아웃이 발생할 때까지<br> 
                    ACK세그먼트를 받지 못하면 재전송</li>
                <li>재전송 기법:<br>
                    ARQ(Automatic Repeat Request)</li>
                <li>수신 호스트의 답변(ACK)과 타임<br>
                    아웃을 토대로 문제를 진단하고,<br>
                    문제가 생긴 메시지를 재전송함으로써<br>
                    신뢰성을 확보하는 방식</li>
                <li>ARQ의 대표적인 3가지 방식</li>
                <li>Stop-and-Wait ARQ<br>
                    제대로 전달했음을 확인하기<br> 
                    전까지는 새로운 메시지를 보내지<br> 
                    않는 방식,송신하고,확인받고,<br>
                    송신하고,확인받고 반복<br>
                    장점:단순하지만,높은 신뢰성을 보장<br>
                    단점:네트워크의 이용효율이<br> 
                    낮아지고 성능이 저하됨<br>
                    송신호스트A:확인응답을 받기 전에는<br>
                    더 보내고 싶어도 못 보냄<br>
                    수신호스트B:더 많은 데이터를 처리할<br> 
                    수 있어도 하나씩만 확인 응답<br>
                    이러한 문제점 해결방법<br>
                    각 세그먼트에 대한 ACK세그먼트가<br> 
                    도착하기 전이더라도 여러 세그먼트를<br> 
                    보낼 수 있어야함<br>
                    파이프라이닝(pipelining):<br>
                    연속해서 메시지를 전송할 수 있는 기술</li>
                <li>Go-Back-N ARQ<br>
                    파이프라이닝 기반ARQ일종<br>
                    여러 세그먼트 전송 중 오류가 발생하면<br>
                    해당 세그먼트부터 전부 재전송<br>
                    순서 번호 n번에 대한 ACK세그먼트는<br> 
                    n번만의 확인 응답이 아닌n번 까지의<br> 
                    누적 확인 응답(CACK,<br>
                    Cumulative Acknowledgment)<br>
                    참고:빠른 재전송(fast retransmit)<br>
                    재전송 타이머가 만료되기 전이라도<br> 
                    세 번의 동일한 ACK세그먼트를<br> 
                    받았다면 곧바로 재전송<br>
                    타이머가 끝날 때까지 기다리는<br>
                    시간을 줄일 수 있음</li>
                <li>Selective Repeat ARQ<br>
                    선택적으로 재전송:각각의 패킷들에<br> 
                    대해 ACK세그먼트를 보내는 방식<br>
                    Go-Back-N ARQ의 ACK세그먼트가<br> 
                    누적 확인 응답이라면,<br>
                    Selective Repeat ARQ의<br> 
                    ACK세그먼트는 개별 확인 응답<br>
                    (Selective Acknowledgment)<br>
                    오늘날의 대부분의 호스트는<br> 
                    Selective Repeat ARQ를<br> 
                    사용하지 않을 경우<br>
                    Go-Back-N ARQ로 동작</li>
                <li>파이프라이닝 기반이더라도<br> 
                    무한으로 데이터를 보낼 수는 없다</li>
                <li>정상 동작하려면 수신 호스트가<br> 
                    한번에 얼마나 바다 처리할 수<br> 
                    있는지 반드시 고려해야함</li>
                <li>호스트가 한번에 받아서 처리할 수<br> 
                    있는 세그먼트의 양에는 한계가<br> 
                    있기때문,한번에 n개의바이트를<br> 
                    받아서 처리할 수 있다면<br> 
                    n바이트만 보내야함 </li>
            <h4>TCP의 흐름 제어</h4>    
                <li>송신 호스트가 수신 호스트의 처리<br> 
                    속도를 고려하며 송수신 속도를<br> 
                    균일하게 유지하는 기능<br>
                    Stop-and-Wait ARQ를 사용하면<br> 
                    별도의 흐름 제어가 필요하지 않음<br>
                    파이프라이닝 기반의 ARQ에서는 필요</li>
            <h4>슬라이딩 윈도우:TCP흐름 제어 기법</h4>    
                <li>윈도우-송신호스트가 파이프라이닝<br> 
                    할 수 있는 최대량, 즉 윈도우 크기 만큼<br>
                    확인 응답을 받지 않고도<br> 
                    한번에 전송 가능하다는 의미</li>
                <li>수신 호스트로부터 첫 번째 세그먼트에<br> 
                    대한ACK세그먼트를 받았다면<br>
                    윈도우는 오른쪽으로 한칸 이동</li>
                <li>송신 측의 윈도우도 있다<br>
                    수신 호스트는 TCP헤더(윈도우필드)<br>
                    를 통해 송신 호스트에게 자신이<br> 받을
                    데이터의 양을 알려줌<br>
                    송신 윈도우:헤더로 전달 받은<br> 
                    수신 윈도우 토대로 연산</li>
            <h4>혼잡(congestion)</h4>
                <li>많은 트래픽으로 인해 패킷의<br> 
                    처리 속도가 늦어지거나 유실될<br> 
                    우려가 있는 네트워크 상황</li>
                <li>TCP의 혼잡 제어:<br>
                    송신 호스트가 혼잡한 정도에 맞춰<br> 
                    유동적으로 전송량을 조절하는 기능<br>
                    흐름 제어의 주체가 수신 호스트라면<br> 
                    혼잡 제어의 주체는 송신 호스트</li>
                <li>혼잡 윈도우-혼잡 없이 전송할 수<br> 
                    있을 법한 데이터양<br>
                    혼잡 윈도우가 크면 한번 에 전송할<br> 
                    수 있는 세그먼트 수가 많음<br>
                    혼잡 윈도우가 작으면<br>
                    (네트워크가 혼잡한 상황)한번에<br>
                    전송할 수 있는 세그먼트 수가 적음</li>
                <li>수신 윈도우는 수신 호스트가<br> 
                    헤더로 알려줌</li>
                <li>혼잡 윈도우는 송신 호스트가 알아서<br>
                    직접 계산해서 알아내야 함</li>
            <h4>TCP의 혼잡 제어 알고리즘</h4>    
                <li>혼잡 제어를 수행하는 일련의 방법</li>
                <li>가장 기본적인 알고리즘인<br> 
                    AIMD(Additive Increase/<br>
                    Multiplicative Decease)</li>
                <li>합으로 증가, 곱으로 감소</li>
                <li>혼잡이 감지되지 않는다면 혼잡<br> 
                    윈도우를 RTT(Round Trip Time)<br>
                    마다 1씩 선형적으로 증가</li>
                <li>혼잡이 감지되면 혼잡 윈도우를<br> 
                    절반으로 떨어뜨리는 동작을 반복</li>
                <li>RTT:메시지를 전송한뒤 그에 대한<br>
                    답변을 받는데 까지 걸리는 시간</li>
                <li>$ ping -c www.google.com</li>
            <h4>느린 시작(slow start) 알고리즘</h4>    
                <li>혼잡 윈도우를 1부터 시작해<br> 
                    문제없이 수신된 ACk세그먼트<br> 
                    하나당 1씩 증가시키는 방식</li>
                <li>혼잡 윈도우를 RTT마다 2배씩<br> 
                    지수적으로 증가<br>
                    초기 전송 속도 빠른 확보</li>
                <li>느린 시작 임계치(threshold)</li>
                <li>혼잡 윈도우 값이 계속 증가하다가<br>
                    혼잡 윈도우 크기가 느린 시작<br> 임계치
                    이상이 되거나,타임아웃 되거나<br>
                    세번의 중복 된 ACK세그먼트를<br> 
                    수신하면 다음 세가지 방법중 하나 선택</li>
                <li>타임아웃 발생:혼잡 윈도우 값을 1로<br>
                    느린 시작 임계치를 혼잡이 감지<br>
                    되었을 시점의 혼잡 윈도우 값의<br> 
                    절반으로 초기화 한뒤 느리 시작 재개</li>
                <li>혼잡윈도우>=느린 시작 임계치:<br>
                    느린 시작 종료,혼잡회피 수행</li>
                <li>세 번의 중복 ACK발생:<br>
                    (빠른 재선송후)빠른 회복 수행</li>
            <h4>혼잡 회피 알고리즘</h4>    
                <li>RTT마다 혼잡 윈도우를 1MSS씩<br>
                    증가시키는 알고리즘</li>
                <li>혼잡 윈도우 크기 선형적으로 증가</li>
                <li>워워워:느린 시작 임계치를 넘어서면<br>
                    혼잡 여지가 있으니 조심해서<br> 
                    혼잡 윈도우 증가하기</li>
            <h4>빠른 회복 알고리즘</h4>    
                <li>세 번의 중복 세그먼트 수신 VS<br>
                    타임 아웃 뭐가 더 심각할까?</li>
                <li>보통 타임 아웃이 더 심각함</li>
                <li>세번의 중복된ACK세그먼트 수신:<br>
                    빠른재전송+빠른회복 알고리즘</li>
                <li>빠른 전송률 회복을 위해<br> 
                    느린 시작은 건너뛰고 혼잡<br> 
                    회피를 수행하는 알고리즘</li>
                <li>단,빠른 히ㅗ복 도중이라도<br> 
                    타임아웃이 발생하면 다시 느린<br> 
                    시작을 수행</li>
            <h4>ECN:명시적 혼잡 알림</h4>    
                <li>중간노드의 도움으로 혼잡을 제어</li>
                <li>혼잡 감지,혼잡윈도우계산,재전송:<br>
                    오로지 송신 호스트의 몫</li>
                <li>혼잡을 피하기 위해 네트워크 중간<br>
                    장치(주로 라우터)의 도움을 받는 방법</li>
                <li>호스트가 ECN을 지원할 경우:<br>
                    TCP/IP헤더에 ECN관련 비트 추가</li>
                <li>ECN을 통한 혼잡 제어</li>
                <li>송신 호스트만 혼잡제어를 수행할<br> 
                    경우 문제가 발생한 이후에<br> 
                    비로소 혼잡 제어</li>
                <li>ECN을 이용하면 수신 호스트의 ACK<br>
                    세그먼터를 통해 더빠르게 혼잡을 감지</li>
            <h4>DNS와 자원</h4>    
                <li>메시지를 주고 받는 송수신지 파악<br>
                    IP주소,도메인 네임</li>
                <li>송수신 하고자 하는 정보 파악<br>
                    자원</li>
                <li>IP주소만으로 송수신지를<br>
                    특정하는 것은 번거로움</li>
                <li>모든친구의 번호를 기억하기 어려움</li>
                <li>통신하고자하는 모든 호스트의<br>
                    IP주소를 기억하기 어려움</li>
                <li>IP주소는 언제든 바뀔 수 있음</li>
                <li>그래서 상대 호스트 특정을 위해<br> 
                    도메인 네임 사용</li>
                <li>도메인 네임:전화번호에<br> 
                    대응하는 사용자 이름<br>
                    호스트의IP주소와 대응되는 문자열<br> 
                    형태의 호스트 특정 정보<br>
                    예:www.google.com<br>
                    </li>
                <li>네임 서버(DNS서버)에서 관리<br>
                    (공용전화번호부)<br>
                    IP주소 변경되어도 도메인 네임<br>
                    다시 대응하면 그만</li>
                <li>개인 전화번호부와도 같은 hosts파일<br>
                    도메인 네임과 IP주소의<br> 
                    대응 관계를 담은 파일<br>
                    hosts파일 위치:<br>
                    맥OS,리눅스-/etc/hosts<br>
                    윈도우-%SystemRoot%/System32<br>
                    /drivers/ect/hosts</li>
            <h4>네임 서버의 관리</h4>    
                <li>도엠인 네임의 구조로 알아보는<br> 
                    네임 서버 관리 방법</li>
                <li>점(.)을 기준으로 계층적으로 분류</li>
                <li>루트 도메인(root domain)<br>
                    점.</li>
                <li>최상위 도메인(Top-level-domain)<br>
                    (TLD)com,kr</li>
                <li>2단계,3단계,4단계도메인...<br>
                    co,ac,google<br>
                    www,habit,www,api,blog</li>
                <li>전체 주소 도메인 네임(FQDN)<br>
                    Fully-Qualified-Domain-name<br>
                    전체 도메인 계층을 모두<br>
                    포함하는 도메인 네임<br>
                    FQDN까지 알면 비로소 하나의<br> 
                    호스트를 식별할 수 있게 됨</li>
                <li>www.google.com.<br>
                    전체:FQDN<br>
                    WWW:3단계 도메인<br>
                    google:2단계 도메인<br>
                    com:최상위 도메인<br>
                    .:루트 도메인</li>
                <li>서브 도메인:다른 도메인이<br> 
                    포함된 도메인<br>
                    google.com의 서브 도메인<br>
                    mail.google.com<br>
                    www.google.com<br>
                    scholar.google.com<br>
                    drive.google.com</li>
            <h4>계층적 도메인 네임</h4>    
                <li>이를 관리하기 위한<br> 
                    네임 서버 또한 계층적으로 관리<br>
                    네임 서버는 전세계 <br>
                    여러 군데 분산되어 위치</li>
                <li>계층적이고 분산된 도메인<br> 
                    네임에 대한 관리 체계:<br>
                    Domain Name System,DNS</li>
            <h4>도메인 네임에 대응하는<br> 
                IP주소를 알아내는 과정</h4>
                <li>도메인 네임을 풀이(resolve)한다</li>
                <li>계층적이고 분산된<br> 
                    네임 서버들이 사용됨</li>
                <li>주요 네임 서버의 유형:<br>
                    로컬 네임 서버,루트 네임 서버,<br>
                    TLD네임 서버,책임 네임 서버</li>
                <li>로컬 네임 서버(local name server)<br>
                    클라이언트와 맞닿아 있는 네임 서버<br>
                    클라이언트가 도메인 네임을 통해<br> 
                    IP주소를 알아내고자할 때 가장 먼저<br> 
                    찾게 되는 네임 서버<br>
                    로컬 네임 서버의 주소는 일반적으로<br>
                    ISP에서 할당<br>
                    공개DNS서버(public DNS server)<br>
                    를 이용할 수도 있음<br>
                    예:구글의8.8.8.8,8.8.8.4<br>
                    클라우드플레이어의1.1.1.1</li>
                <li>루트네임서버(root name server):<br>
                    루트 도메인을 관장하는 네임 서버<br>
                    로컬 네임 서버가 대응되는 IP주소를<br> 
                    모를 경우 TLD네임 서버의 IP주소를<br>
                    반환할 수 있음</li>
                <li>TLD네임 서버:<br>
                    TLD을 관리하는 네임 서버<br>
                    DNS질의에 대해 TLD의 하위 도메인<br> 
                    네임을 관리하는 네임 서버 주소 반환<br>
                    하위 도메인 네임을 관리하는 네임<br> 
                    서버는 그보다 하위도메인 네임을<br> 
                    관리하는 네임 서버 주소를 반환</li>
                <li>책임 네임 서버<br>
                    (authoritative name server):<br>
                    특정 도메인 영역을 관리하는 네임서버<br>
                    다른 네임 서버에게 떠넘기지 않고<br> 
                    곧바로 답할 할 수 있는 네임 서버<br>
                    즉,책임 네임 서버는 로컬 네임 서버가<br>
                    마지막으로 질의하는 네임 서버<br>
                    일반적으로 로컬 네임 서버는<br> 
                    책임 네임 서버로부터 원하는<br> 
                    IP주소를 얻어냄</li>
            <h4>네임 서버의 계층적 구조를 토대로<br>
                IP주소를 알아내는 과정</h4>    
                <li>재귀적 질의(recursive query)<br>
                    클라이언트->로컬네임서버-><br>
                    루트네임서버->TLD네임서버-><br>
                    책임네임서버에게 질의<br>
                    최종 응답 결과를 역순으로 전달</li>
                <li>반복적 질의(iterative query)<br>
                    네임 서버에 일일이 질의-응답 반복<br>
                    최종 음답 결과를 클라이언트에게 전달</li>
                <li>하지만 조금 문제가 있다<br>
                    앞선 예시는 8단계를 거치게 됨<br>
                    시간이 오래 걸리고 네트워크상의<br>
                    메시지 수가 지나치게 늘어날 수 있음<br>
                    루트 네임 서버 과부하 우려</li>
            <h4>DNS 캐시</h4>    
                <li>네임 서버들이 기존에 응답받은<br> 
                    결과를 임시로 저장했다가 추후<br>
                    같은 질의에 이를 활용</li>
                <li>DNS캐시를 저장하는 용도로만<br> 
                    사용되는 서버도 있음</li>
                <li>DNS캐시를 활용하면 더 짧은 시간<br> 
                    안에 원하는 IP주소를 얻어낼 수 있음</li>
                <li>DNS캐시는 영원히 남아있는 것음 아님</li>
                <li>임시 저장된 값은 TTL값과 함께 저장</li>
                <li>TTL:Time To Live 캐시될수 있는 시간</li>
            <h4>자원을 식별하는 URI</h4>    
                <li>자원(resource)-네트워크상의<br> 
                    메시지를 통해 주고받는 대상</li>
                <li>두 호스트가 네트워크를 통해 서로<br> 
                    정보를 주고받을때 송수신하는 대상<br>
                    HTML,이미지나동영상,텍스트파일</li>
                <li>자원은 HTTP요청 메시지의<br> 
                    대상이라 보기도 한다</li>
                <li>자원을 식별할 수 있는 정보<br>
                    URI(Uniform Resource Identifier)</li>
                <li>URL(Uniform Resource Locator)<br>
                    위치를 이용해 자원을 식별</li>
                <li>URN(Uniform Resource Name)<br>
                    이름을 이용해 자원을 식별</li>
                <li>URL:오늘날 인터넷 환경에서 자원<br>
                    식별에 더 많이 사용되는 식별자</li>
                <li>URL의 구조(RFC3986)</li>
                <li>scheme(foo:)</li>
                <li>authority(www.example.com:8042)</li>
                <li>path(/over/there)</li>
                <li>query(?name=ferret)</li>
                <li>fragment(#nose)</li>
                <li>scheme:URL의 첫 부분 자원에<br> 
                    접근하는 방법을 의미 일반적으로<br>
                    사용할 프로토콜이 명시<br>  
                    HTTP://<br>
                    HTTPS://</li>
                <li>authority:호스트를 특정할수 있는<br> 
                    정보 이를테면 IP 주소 혹은 도메인<br>
                    네임이 명시 콜로(:)뒤에<br> 포트
                    번호를 덧붙일 수도 있음</li>
                <li>path:자원이 위치한 경로가 명시<br>
                    자원의 위치는 슬래시(/)를<br> 
                    기준으로 계층적으로 표현되고<br>
                    최상위 경로 또한 슬래시로 표현</li>
                <li>query:HTTP는 요청-응답 기반의<br> 
                    프로토콜,클라이언트는 서버에게<br>
                    URI(URL)가 포함된 HTTP 요청<br> 
                    메시지를 보내고 HTTP서버는<br> 
                    이에 대해 HTTP응답 메시지를 보냄</li>
                <li>scheme,authority,path만으로는<br> 
                    요청할 수 있는 정보의 한계가 있다</li>
                <li>이런 한계를 극복하기 위한query</li>
                <li>쿼리 문자열(query string)</li>
                <li>쿼리 파라미터(query parameter)</li>
                <li>물음표(?)로 시작되는<br> 
                    (키,값) 형태의 데이터</li>
                <li>엠퍼샌드(&)로 여러 쿼리<br> 
                    문자열을 덧붙일 수 있음</li>
                <li>물론 개발자가 설계하기 나름</li>
                <li>지역:location</li>
                <li>침실수:rooms</li>
                <li>면적:size</li>
                <li>최소가격:min_price</li>
                <li>/search?location=seoul&rooms<br>
                    =2&size=100&min_price=20000</li>
                <li>fragment:자원의 한 조각을 가리<br>
                    키기 위한 정보,HTML파일과 같은<br>
                    자원에서 특정부분을<br> 
                    가리키기 위해 사용</li>
                <li>URL의 단점<br>
                    위치를 기반으로 자원을 식별하는데<br>
                    자원 위치는 언제든 변할 수 있음<br>
                    즉,자원의 위치가 변경되면 기존<br> 
                    URL로는 자원을 식별할 수 없음</li>
                <li>URN의 장점<br>
                    자원의 고유한 이름을 붙이는 이름<br> 
                    기반 식별자이기에 자원의 위치와<br> 
                    무관한게 자원을 식별</li>
            <h4>DNS레코드 타입</h4>        
                <li>네임서버는 무엇을 저장 할까</li>
                <li>DNS자원 레코드</li>
                <li>이름(호스트 이름,Record Name)</li>
                <li>값(Value)</li>
                <li>TTL</li>
                <li>레코드 유형(타입Record type)등</li>
            <h4><a href="page_network8.html"> NW part8 </a></h4>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>