<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part7</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp" alt=""/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript2.html"> JavaScript</a></li>
            <li><a href="page_javascript.html"> JavaScript-with nodejs </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_datastr.html"> Data-Structure </a></li>
            <li><a href="page_cs1.html"> CS知識1 </a></li>
            <li><a href="page_cs2.html"> CS知識2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network-OSI model </a></li>
            <li><a href="page_network2.html"> Physical-Data-layer1 </a></li>
            <li><a href="page_network3.html"> Physical-Data-layer2 </a></li>
            <li><a href="page_network4.html"> Network-layer1 </a></li>
            <li><a href="page_network5.html"> Network-layer2 </a></li>
            <li><a href="page_network6.html"> Transport-layer </a></li>
            <li><a href="page_network7.html"> Application-layer1 </a></li>
            <li><a href="page_network8.html"> Application-layer2 </a></li>
            <li><a href="page_network9.html"> Application-layer3 </a></li>
            <li><a href="page_network10.html"> Application-layer4 </a></li>
            <li><a href="page_network11.html"> Application-layer5 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Application-layer1</h2>
            <ul>
            <h4>DNS와 자원</h4>    
                <li>메시지를 주고 받는 송수신지 파악<br>
                    IP주소,도메인 네임</li>
                <li>송수신 하고자 하는 정보 파악<br>
                    자원</li>
                <li>IP주소만으로 송수신지를<br>
                    특정하는 것은 번거로움</li>
                <li>모든친구의 번호를 기억하기 어려움</li>
                <li>통신하고자하는 모든 호스트의<br>
                    IP주소를 기억하기 어려움</li>
                <li>IP주소는 언제든 바뀔 수 있음</li>
                <li>그래서 상대 호스트 특정을 위해<br> 
                    도메인 네임 사용</li>
                <li>도메인 네임:전화번호에<br> 
                    대응하는 사용자 이름<br>
                    호스트의IP주소와 대응되는 문자열<br> 
                    형태의 호스트 특정 정보<br>
                    예:www.google.com<br>
                    </li>
                <li>네임 서버(DNS서버)에서 관리<br>
                    (공용전화번호부)<br>
                    IP주소 변경되어도 도메인 네임<br>
                    다시 대응하면 그만</li>
                <li>개인 전화번호부와도 같은 hosts파일<br>
                    도메인 네임과 IP주소의<br> 
                    대응 관계를 담은 파일<br>
                    hosts파일 위치:<br>
                    맥OS,리눅스-/etc/hosts<br>
                    윈도우-%SystemRoot%/System32<br>
                    /drivers/ect/hosts</li>
            <h4>네임 서버의 관리</h4>    
                <li>도엠인 네임의 구조로 알아보는<br> 
                    네임 서버 관리 방법</li>
                <li>점(.)을 기준으로 계층적으로 분류</li>
                <li>루트 도메인(root domain)<br>
                    점.</li>
                <li>최상위 도메인(Top-level-domain)<br>
                    (TLD)com,kr</li>
                <li>2단계,3단계,4단계도메인...<br>
                    co,ac,google<br>
                    www,habit,www,api,blog</li>
                <li>전체 주소 도메인 네임(FQDN)<br>
                    Fully-Qualified-Domain-name<br>
                    전체 도메인 계층을 모두<br>
                    포함하는 도메인 네임<br>
                    FQDN까지 알면 비로소 하나의<br> 
                    호스트를 식별할 수 있게 됨</li>
                <li>www.google.com.<br>
                    전체:FQDN<br>
                    WWW:3단계 도메인<br>
                    google:2단계 도메인<br>
                    com:최상위 도메인<br>
                    .:루트 도메인</li>
                <li>서브 도메인:다른 도메인이<br> 
                    포함된 도메인<br>
                    google.com의 서브 도메인<br>
                    mail.google.com<br>
                    www.google.com<br>
                    scholar.google.com<br>
                    drive.google.com</li>
            <h4>계층적 도메인 네임</h4>    
                <li>이를 관리하기 위한<br> 
                    네임 서버 또한 계층적으로 관리<br>
                    네임 서버는 전세계 <br>
                    여러 군데 분산되어 위치</li>
                <li>계층적이고 분산된 도메인<br> 
                    네임에 대한 관리 체계:<br>
                    Domain Name System,DNS</li>
            <h4>도메인 네임에 대응하는<br> 
                IP주소를 알아내는 과정</h4>
                <li>도메인 네임을 풀이(resolve)한다</li>
                <li>계층적이고 분산된<br> 
                    네임 서버들이 사용됨</li>
                <li>주요 네임 서버의 유형:<br>
                    로컬 네임 서버,루트 네임 서버,<br>
                    TLD네임 서버,책임 네임 서버</li>
                <li>로컬 네임 서버(local name server)<br>
                    클라이언트와 맞닿아 있는 네임 서버<br>
                    클라이언트가 도메인 네임을 통해<br> 
                    IP주소를 알아내고자할 때 가장 먼저<br> 
                    찾게 되는 네임 서버<br>
                    로컬 네임 서버의 주소는 일반적으로<br>
                    ISP에서 할당<br>
                    공개DNS서버(public DNS server)<br>
                    를 이용할 수도 있음<br>
                    예:구글의8.8.8.8,8.8.8.4<br>
                    클라우드플레이어의1.1.1.1</li>
                <li>루트네임서버(root name server):<br>
                    루트 도메인을 관장하는 네임 서버<br>
                    로컬 네임 서버가 대응되는 IP주소를<br> 
                    모를 경우 TLD네임 서버의 IP주소를<br>
                    반환할 수 있음</li>
                <li>TLD네임 서버:<br>
                    TLD을 관리하는 네임 서버<br>
                    DNS질의에 대해 TLD의 하위 도메인<br> 
                    네임을 관리하는 네임 서버 주소 반환<br>
                    하위 도메인 네임을 관리하는 네임<br> 
                    서버는 그보다 하위도메인 네임을<br> 
                    관리하는 네임 서버 주소를 반환</li>
                <li>책임 네임 서버<br>
                    (authoritative name server):<br>
                    특정 도메인 영역을 관리하는 네임서버<br>
                    다른 네임 서버에게 떠넘기지 않고<br> 
                    곧바로 답할 할 수 있는 네임 서버<br>
                    즉,책임 네임 서버는 로컬 네임 서버가<br>
                    마지막으로 질의하는 네임 서버<br>
                    일반적으로 로컬 네임 서버는<br> 
                    책임 네임 서버로부터 원하는<br> 
                    IP주소를 얻어냄</li>
            <h4>네임 서버의 계층적 구조를 토대로<br>
                IP주소를 알아내는 과정</h4>    
                <li>재귀적 질의(recursive query)<br>
                    클라이언트->로컬네임서버-><br>
                    루트네임서버->TLD네임서버-><br>
                    책임네임서버에게 질의<br>
                    최종 응답 결과를 역순으로 전달</li>
                <li>반복적 질의(iterative query)<br>
                    네임 서버에 일일이 질의-응답 반복<br>
                    최종 음답 결과를 클라이언트에게 전달</li>
                <li>하지만 조금 문제가 있다<br>
                    앞선 예시는 8단계를 거치게 됨<br>
                    시간이 오래 걸리고 네트워크상의<br>
                    메시지 수가 지나치게 늘어날 수 있음<br>
                    루트 네임 서버 과부하 우려</li>
            <h4>DNS 캐시</h4>    
                <li>네임 서버들이 기존에 응답받은<br> 
                    결과를 임시로 저장했다가 추후<br>
                    같은 질의에 이를 활용</li>
                <li>DNS캐시를 저장하는 용도로만<br> 
                    사용되는 서버도 있음</li>
                <li>DNS캐시를 활용하면 더 짧은 시간<br> 
                    안에 원하는 IP주소를 얻어낼 수 있음</li>
                <li>DNS캐시는 영원히 남아있는 것음 아님</li>
                <li>임시 저장된 값은 TTL값과 함께 저장</li>
                <li>TTL:Time To Live 캐시될수 있는 시간</li>
            <h4>자원을 식별하는 URI</h4>    
                <li>자원(resource)-네트워크상의<br> 
                    메시지를 통해 주고받는 대상</li>
                <li>두 호스트가 네트워크를 통해 서로<br> 
                    정보를 주고받을때 송수신하는 대상<br>
                    HTML,이미지나동영상,텍스트파일</li>
                <li>자원은 HTTP요청 메시지의<br> 
                    대상이라 보기도 한다</li>
                <li>자원을 식별할 수 있는 정보<br>
                    URI(Uniform Resource Identifier)</li>
                <li>URL(Uniform Resource Locator)<br>
                    위치를 이용해 자원을 식별</li>
                <li>URN(Uniform Resource Name)<br>
                    이름을 이용해 자원을 식별</li>
                <li>URL:오늘날 인터넷 환경에서 자원<br>
                    식별에 더 많이 사용되는 식별자</li>
                <li>URL의 구조(RFC3986)</li>
                <li>scheme(foo:)</li>
                <li>authority(www.example.com:8042)</li>
                <li>path(/over/there)</li>
                <li>query(?name=ferret)</li>
                <li>fragment(#nose)</li>
                <li>scheme:URL의 첫 부분 자원에<br> 
                    접근하는 방법을 의미 일반적으로<br>
                    사용할 프로토콜이 명시<br>  
                    HTTP://<br>
                    HTTPS://</li>
                <li>authority:호스트를 특정할수 있는<br> 
                    정보 이를테면 IP 주소 혹은 도메인<br>
                    네임이 명시 콜로(:)뒤에<br> 포트
                    번호를 덧붙일 수도 있음</li>
                <li>path:자원이 위치한 경로가 명시<br>
                    자원의 위치는 슬래시(/)를<br> 
                    기준으로 계층적으로 표현되고<br>
                    최상위 경로 또한 슬래시로 표현</li>
                <li>query:HTTP는 요청-응답 기반의<br> 
                    프로토콜,클라이언트는 서버에게<br>
                    URI(URL)가 포함된 HTTP 요청<br> 
                    메시지를 보내고 HTTP서버는<br> 
                    이에 대해 HTTP응답 메시지를 보냄</li>
                <li>scheme,authority,path만으로는<br> 
                    요청할 수 있는 정보의 한계가 있다</li>
                <li>이런 한계를 극복하기 위한query</li>
                <li>쿼리 문자열(query string)</li>
                <li>쿼리 파라미터(query parameter)</li>
                <li>물음표(?)로 시작되는<br> 
                    (키,값) 형태의 데이터</li>
                <li>엠퍼샌드(&)로 여러 쿼리<br> 
                    문자열을 덧붙일 수 있음</li>
                <li>물론 개발자가 설계하기 나름</li>
                <li>지역:location</li>
                <li>침실수:rooms</li>
                <li>면적:size</li>
                <li>최소가격:min_price</li>
                <li>/search?location=seoul&rooms<br>
                    =2&size=100&min_price=20000</li>
                <li>fragment:자원의 한 조각을 가리<br>
                    키기 위한 정보,HTML파일과 같은<br>
                    자원에서 특정부분을<br> 
                    가리키기 위해 사용</li>
                <li>URL의 단점<br>
                    위치를 기반으로 자원을 식별하는데<br>
                    자원 위치는 언제든 변할 수 있음<br>
                    즉,자원의 위치가 변경되면 기존<br> 
                    URL로는 자원을 식별할 수 없음</li>
                <li>URN의 장점<br>
                    자원의 고유한 이름을 붙이는 이름<br> 
                    기반 식별자이기에 자원의 위치와<br> 
                    무관한게 자원을 식별</li>
            <h4>DNS레코드 타입</h4>        
                <li>네임서버는 무엇을 저장 할까</li>
                <li>DNS자원 레코드</li>
                <li>이름(호스트 이름,Record Name)</li>
                <li>값(Value)</li>
                <li>TTL</li>
                <li>레코드 유형(타입Record type)등</li>
            <h4><a href="page_network8.html"> Application-layer2 </a></h4>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>