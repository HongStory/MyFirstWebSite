<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part7</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network </a></li>
            <li><a href="page_network2.html"> NW part2 </a></li>
            <li><a href="page_network3.html"> NW part3 </a></li>
            <li><a href="page_network4.html"> NW part4 </a></li>
            <li><a href="page_network5.html"> NW part5 </a></li>
            <li><a href="page_network6.html"> NW part6 </a></li>
            <li><a href="page_network7.html"> NW part7 </a></li>
            <li><a href="page_network8.html"> NW part8 </a></li>
            <li><a href="page_network9.html"> NW part9 </a></li>
            <li><a href="page_network10.html"> NW part10 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Network part7</h2>
            <ul>
            <h4>TCP의 오류:흐름,혼잡제어</h4>    
                <li>TCP의 기능:재전송을 기반으로<br> 
                    다양한 오류를 제어,흐름 제어를<br> 
                    통해 처리할 수 있을 만큼의<br> 
                    데이터 송수신,혼잡 제어를 통해<br> 
                    네트워크가 혼잡한 정도에<br> 
                    따라 전송량 조절</li>
            <h4>재전송 기반의 오류 제어</h4>    
                <li>오류 검출과 재전송</li>    
                <li>TCP세그먼트의 체크섬 필드,충분할까?</li>
                <li>TCP가 신뢰성을 제대로 보장하려면?</li>
                <li>송신 호스트가 송신한 세그먼트에<br> 
                    문제가 발생했음을 인지할수 있어야</li>
                <li>오류를 감지하게 되면 해당<br>
                    세그먼트를 재전송할 수 있어야</li>
                <li>그렇다면 TCP는 언제 오류를<br> 
                    검출하고 재전송할까?</li>
                <li>중복된ACK세그먼트를 수신했을때</li>
                <li>타임아웃이 발생했을때</li>
                <li>호스트가 세그먼트를 전송할<br> 
                    때마다 재전송 타이머 시작</li>
                <li>타임아웃이 발생할 때까지<br> 
                    ACK세그먼트를 받지 못하면 재전송</li>
                <li>재전송 기법:<br>
                    ARQ(Automatic Repeat Request)</li>
                <li>수신 호스트의 답변(ACK)과 타임<br>
                    아웃을 토대로 문제를 진단하고,<br>
                    문제가 생긴 메시지를 재전송함으로써<br>
                    신뢰성을 확보하는 방식</li>
                <li>ARQ의 대표적인 3가지 방식</li>
                <li>Stop-and-Wait ARQ<br>
                    제대로 전달했음을 확인하기<br> 
                    전까지는 새로운 메시지를 보내지<br> 
                    않는 방식,송신하고,확인받고,<br>
                    송신하고,확인받고 반복<br>
                    장점:단순하지만,높은 신뢰성을 보장<br>
                    단점:네트워크의 이용효율이<br> 
                    낮아지고 성능이 저하됨<br>
                    송신호스트A:확인응답을 받기 전에는<br>
                    더 보내고 싶어도 못 보냄<br>
                    수신호스트B:더 많은 데이터를 처리할<br> 
                    수 있어도 하나씩만 확인 응답<br>
                    이러한 문제점 해결방법<br>
                    각 세그먼트에 대한 ACK세그먼트가<br> 
                    도착하기 전이더라도 여러 세그먼트를<br> 
                    보낼 수 있어야함<br>
                    파이프라이닝(pipelining):<br>
                    연속해서 메시지를 전송할 수 있는 기술</li>
                <li>Go-Back-N ARQ<br>
                    파이프라이닝 기반ARQ일종<br>
                    여러 세그먼트 전송 중 오류가 발생하면<br>
                    해당 세그먼트부터 전부 재전송<br>
                    순서 번호 n번에 대한 ACK세그먼트는<br> 
                    n번만의 확인 응답이 아닌n번 까지의<br> 
                    누적 확인 응답(CACK,<br>
                    Cumulative Acknowledgment)<br>
                    참고:빠른 재전송(fast retransmit)<br>
                    재전송 타이머가 만료되기 전이라도<br> 
                    세 번의 동일한 ACK세그먼트를<br> 
                    받았다면 곧바로 재전송<br>
                    타이머가 끝날 때까지 기다리는<br>
                    시간을 줄일 수 있음</li>
                <li>Selective Repeat ARQ<br>
                    선택적으로 재전송:각각의 패킷들에<br> 
                    대해 ACK세그먼트를 보내는 방식<br>
                    Go-Back-N ARQ의 ACK세그먼트가<br> 
                    누적 확인 응답이라면,<br>
                    Selective Repeat ARQ의<br> 
                    ACK세그먼트는 개별 확인 응답<br>
                    (Selective Acknowledgment)<br>
                    오늘날의 대부분의 호스트는<br> 
                    Selective Repeat ARQ를<br> 
                    사용하지 않을 경우<br>
                    Go-Back-N ARQ로 동작</li>
                <li>파이프라이닝 기반이더라도<br> 
                    무한으로 데이터를 보낼 수는 없다</li>
                <li>정상 동작하려면 수신 호스트가<br> 
                    한번에 얼마나 바다 처리할 수<br> 
                    있는지 반드시 고려해야함</li>
                <li>호스트가 한번에 받아서 처리할 수<br> 
                    있는 세그먼트의 양에는 한계가<br> 
                    있기때문,한번에 n개의바이트를<br> 
                    받아서 처리할 수 있다면<br> 
                    n바이트만 보내야함 </li>
            <h4>TCP의 흐름 제어</h4>    
                <li>송신 호스트가 수신 호스트의 처리<br> 
                    속도를 고려하며 송수신 속도를<br> 
                    균일하게 유지하는 기능<br>
                    Stop-and-Wait ARQ를 사용하면<br> 
                    별도의 흐름 제어가 필요하지 않음<br>
                    파이프라이닝 기반의 ARQ에서는 필요</li>
            <h4>슬라이딩 윈도우:TCP흐름 제어 기법</h4>    
                <li>윈도우-송신호스트가 파이프라이닝<br> 
                    할 수 있는 최대량, 즉 윈도우 크기 만큼<br>
                    확인 응답을 받지 않고도<br> 
                    한번에 전송 가능하다는 의미</li>
                <li>수신 호스트로부터 첫 번째 세그먼트에<br> 
                    대한ACK세그먼트를 받았다면<br>
                    윈도우는 오른쪽으로 한칸 이동</li>
                <li>송신 측의 윈도우도 있다<br>
                    수신 호스트는 TCP헤더(윈도우필드)<br>
                    를 통해 송신 호스트에게 자신이<br> 받을
                    데이터의 양을 알려줌<br>
                    송신 윈도우:헤더로 전달 받은<br> 
                    수신 윈도우 토대로 연산</li>
            <h4>혼잡(congestion)</h4>
                <li>많은 트래픽으로 인해 패킷의<br> 
                    처리 속도가 늦어지거나 유실될<br> 
                    우려가 있는 네트워크 상황</li>
                <li>TCP의 혼잡 제어:<br>
                    송신 호스트가 혼잡한 정도에 맞춰<br> 
                    유동적으로 전송량을 조절하는 기능<br>
                    흐름 제어의 주체가 수신 호스트라면<br> 
                    혼잡 제어의 주체는 송신 호스트</li>
                <li>혼잡 윈도우-혼잡 없이 전송할 수<br> 
                    있을 법한 데이터양<br>
                    혼잡 윈도우가 크면 한번 에 전송할<br> 
                    수 있는 세그먼트 수가 많음<br>
                    혼잡 윈도우가 작으면<br>
                    (네트워크가 혼잡한 상황)한번에<br>
                    전송할 수 있는 세그먼트 수가 적음</li>
                <li>수신 윈도우는 수신 호스트가<br> 
                    헤더로 알려줌</li>
                <li>혼잡 윈도우는 송신 호스트가 알아서<br>
                    직접 계산해서 알아내야 함</li>
            <h4>TCP의 혼잡 제어 알고리즘</h4>    
                <li>혼잡 제어를 수행하는 일련의 방법</li>
                <li>가장 기본적인 알고리즘인<br> 
                    AIMD(Additive Increase/<br>
                    Multiplicative Decease)</li>
                <li>합으로 증가, 곱으로 감소</li>
                <li>혼잡이 감지되지 않는다면 혼잡<br> 
                    윈도우를 RTT(Round Trip Time)<br>
                    마다 1씩 선형적으로 증가</li>
                <li>혼잡이 감지되면 혼잡 윈도우를<br> 
                    절반으로 떨어뜨리는 동작을 반복</li>
                <li>RTT:메시지를 전송한뒤 그에 대한<br>
                    답변을 받는데 까지 걸리는 시간</li>
                <li>$ ping -c www.google.com</li>
            <h4>느린 시작(slow start) 알고리즘</h4>    
                <li>혼잡 윈도우를 1부터 시작해<br> 
                    문제없이 수신된 ACk세그먼트<br> 
                    하나당 1씩 증가시키는 방식</li>
                <li>혼잡 윈도우를 RTT마다 2배씩<br> 
                    지수적으로 증가<br>
                    초기 전송 속도 빠른 확보</li>
                <li>느린 시작 임계치(threshold)</li>
                <li>혼잡 윈도우 값이 계속 증가하다가<br>
                    혼잡 윈도우 크기가 느린 시작<br> 임계치
                    이상이 되거나,타임아웃 되거나<br>
                    세번의 중복 된 ACK세그먼트를<br> 
                    수신하면 다음 세가지 방법중 하나 선택</li>
                <li>타임아웃 발생:혼잡 윈도우 값을 1로<br>
                    느린 시작 임계치를 혼잡이 감지<br>
                    되었을 시점의 혼잡 윈도우 값의<br> 
                    절반으로 초기화 한뒤 느리 시작 재개</li>
                <li>혼잡윈도우>=느린 시작 임계치:<br>
                    느린 시작 종료,혼잡회피 수행</li>
                <li>세 번의 중복 ACK발생:<br>
                    (빠른 재선송후)빠른 회복 수행</li>
            <h4>혼잡 회피 알고리즘</h4>    
                <li>RTT마다 혼잡 윈도우를 1MSS씩<br>
                    증가시키는 알고리즘</li>
                <li>혼잡 윈도우 크기 선형적으로 증가</li>
                <li>워워워:느린 시작 임계치를 넘어서면<br>
                    혼잡 여지가 있으니 조심해서<br> 
                    혼잡 윈도우 증가하기</li>
            <h4>빠른 회복 알고리즘</h4>    
                <li>세 번의 중복 세그먼트 수신 VS<br>
                    타임 아웃 뭐가 더 심각할까?</li>
                <li>보통 타임 아웃이 더 심각함</li>
                <li>세번의 중복된ACK세그먼트 수신:<br>
                    빠른재전송+빠른회복 알고리즘</li>
                <li>빠른 전송률 회복을 위해<br> 
                    느린 시작은 건너뛰고 혼잡<br> 
                    회피를 수행하는 알고리즘</li>
                <li>단,빠른 히ㅗ복 도중이라도<br> 
                    타임아웃이 발생하면 다시 느린<br> 
                    시작을 수행</li>
            <h4>ECN:명시적 혼잡 알림</h4>    
                <li>중간노드의 도움으로 혼잡을 제어</li>
                <li>혼잡 감지,혼잡윈도우계산,재전송:<br>
                    오로지 송신 호스트의 몫</li>
                <li>혼잡을 피하기 위해 네트워크 중간<br>
                    장치(주로 라우터)의 도움을 받는 방법</li>
                <li>호스트가 ECN을 지원할 경우:<br>
                    TCP/IP헤더에 ECN관련 비트 추가</li>
                <li>ECN을 통한 혼잡 제어</li>
                <li>송신 호스트만 혼잡제어를 수행할<br> 
                    경우 문제가 발생한 이후에<br> 
                    비로소 혼잡 제어</li>
                <li>ECN을 이용하면 수신 호스트의 ACK<br>
                    세그먼터를 통해 더빠르게 혼잡을 감지</li>
            <h4>DNS와 자원</h4>    
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>