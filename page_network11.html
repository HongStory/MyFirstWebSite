<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part11</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp" alt=""/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript2.html"> JavaScript</a></li>
            <li><a href="page_javascript.html"> JavaScript-with Web </a></li>
            <li><a href="page_javascript3.html"> JavaScript-with Nodejs </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_datastr.html"> Data-Structure </a></li>
            <li><a href="page_cs1.html"> CS知識1 </a></li>
            <li><a href="page_cs2.html"> CS知識2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network-OSI model </a></li>
            <li><a href="page_network2.html"> Physical-Data-layer1 </a></li>
            <li><a href="page_network3.html"> Physical-Data-layer2 </a></li>
            <li><a href="page_network4.html"> Network-layer1 </a></li>
            <li><a href="page_network5.html"> Network-layer2 </a></li>
            <li><a href="page_network6.html"> Transport-layer </a></li>
            <li><a href="page_network7.html"> Application-layer1 </a></li>
            <li><a href="page_network8.html"> Application-layer2 </a></li>
            <li><a href="page_network9.html"> Application-layer3 </a></li>
            <li><a href="page_network10.html"> Application-layer4 </a></li>
            <li><a href="page_network11.html"> Application-layer5 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Application-layer5</h2>
            <ul>
            <h4>안전성을 위한 기술1</h4>
                <li>안전성을 수치로 표현하는 가용성</li>
                <li>안전성을 높이기 위한 방법</li>
                <li>이중화와 다중화:<br>
                    물리적 장비나 프로그램등을<br> 
                    여러개 두는 기술</li>
                <li>로드 밸런싱:트래픽을 고르게<br> 
                    분산하는 기술</li>
            <h4>가용성(availability)</h4>    
                <li>컴퓨터 시스템이 특정 기능을<br>
                    실제로 수행할 수 있는 시간의 비율</li>
                <li>전체 사용 시간중에서 정상적인 사용시간</li>
                <li>업타임(uptime):정상적인 사용 시간</li>
                <li>다운타임(downtime):<br>
                    정상적인 사용이 불가능한 시간</li>
                <li>가용성:"업타입" % "업타임+다운타임"</li>
                <li>고가용성(HA,High Availability):<br>
                    가용성이 높음</li>
                <li>일반적으로 안정적인 시스템은<br>
                    99.999%이상을 목표</li>                    
                <li>서비스는 왜 다운될까</li>
                <li>과도한 트래픽</li>
                <li>예기치 못한 소프트웨어상 오류</li>
                <li>하드웨어 장애</li>
                <li>보안 공격이나 자연재해등</li>
                <li>다운타임을 낮추면 된다</li>
                <li>다운 타임의 발생 원인을 모두 찾아<br> 
                    원천적으로 차단할 수 있을까</li>
                <li>핵심은 문제가 발생하지 않도록<br> 
                    하는 것이 아니라 문제가 발생해도<br> 
                    계속 가능하도록 설계하는것</li>
                <li>결함 감내(fault tolerance)</li>
                <li>문제가 발생하더라도 가능할 수 있는 능력</li>
                <li>결함을 감내할 수 있도록 서비스나<br> 
                    인프라를 설계하는 것이 중요</li>
            <h4>결함을 감내하여 가용성을 높이기 위한<br> 
                가장 기본적이고 대표적인 방법</h4>
                <li>예비(백업)를 마련하는 방법</li>
                <li>무엇을 이중화해야 할까</li>
                <li>문제가 발생할 경우 시스템<br> 
                    전체가 중단될 수 있는 대상<br>
                    SPoF(Single Point of Failure)</li>
                <li>서버 컴퓨터,네트워크 인터페이스(NIC),<br>
                    스위치와 같은 물리적 장비</li>
                <li>데이터베이스,웹서버프로그램등</li>
            <h4>구성 방법</h4>    
                <li>액티브/스탠바이(active-standby)<br>
                    한 시스템은 가동하고, 다른 시스템은<br> 
                    백업 용도로 대기 상태(standby)</li>
                <li>액티브/액티브(active-active):<br>
                    두 시스템 모두를 가동 상태</li>
            <h4>이중화의 확장->다중화</h4>
                <li>무언가를 여려개 두는 기술</li>
                <li>이중화/다중화의 사례</li>
                <li>티밍(teaming)과 본딩(bonding)</li>
                <li>티밍-윈도우</li>
                <li>본딩-리눅스</li>
                <li>여러 네트워크 인터페이스(NIC)를<br> 
                    이중화/다중화하여 더 뛰어나고<br> 
                    안정적인 성능의 하나의<br> 
                    인터페이스처럼 보이게 하는 기술</li>
            <h4>로드 밸런싱:<br>
                트래픽의 고른 부내를 위한 기술</h4>    
                <li>고가용성을 요구하는 호스트는<br> 
                    클라이언트보다는 일반적으로 서버</li>
                <li>서버 입장에서 가용성을 더 생각해보기</li>
                <li>서버를 다중화했다면 무조건 안정적일까</li>
                <li>로드 밸러서(load balancer)에의해 수행</li>
                <li>전용 네트워크 장비<br>
                    (L4스위치,L7스위치)로 수행</li>
                <li>L4스위치는IP주소와 포트 번호와<br> 
                    같은 전송 계층까지의 정보를<br> 
                    바탕으로 로드 밸런싱</li>
                <li>L7스위치는 URI,HTTP메시지 일부,<br>
                    쿠키등 응용 계층의 정보까지<br> 
                    활용하여 로드 밸런싱</li>
                <li>로드밸런싱 소프트웨어를<br> 
                    설치하면 일반 호스트들도<br> 
                    로드 밸러서로 사용 가능</li>
                <li>HAProxy,Envoy등</li>
                <li>Nginx에도 로드 밸런싱 기능이 내포</li>
            <h4>로드 밸러서의 위치</h4>    
                <li>일반적으로 이중화/다중화된<br> 
                    서버와 클라이언트 사이에 위치</li>
                <li>클라이언트들은 로드 밸러서에<br> 
                    요청을 보내고, 로드 밸러서는<br> 
                    해당 요청을 각 서버에 균등하게 분배</li>
            <h4>서버의 상태를 검사하는 헬스 체크</h4>    
                <li>헬스 체크(health check)</li>
                <li>서버들의 건강 상태를 주기적으로<br>
                    모니터링하고 체크</li>
                <li>주로 로드 밸런서에 의해 이루어짐</li>
                <li>HTTP,ICMP등 다양한 프로토콜을 활용</li>
                <li>서버간 하트비트(heartbeat)라는<br> 
                    메시지를 주기적으로<br> 
                    주고받는 방법도 있음</li>
            <h4>로드 밸런싱 알고리즘</h4>    
                <li>라운드 로빈 알고리즘<br>
                    (round robin algorithm):<br>
                    단순히 서버를 돌아가며 부하를 전달</li>
                <li>최소 연결 알고리즘<br>
                    (least connection algorithm):<br>
                    연결이 적은 서버부터<br> 
                    우선적으로 부하를 전달</li>
                <li>기타:1.단순히 무작위로 고르는 알고리즘<br>
                    2.해시(hash):<br>
                    자료구조를 이용하는 알고리즘<br>
                    3.응답 시간이 가장 짧은<br> 
                    서버를 선택하는 알고리즘</li>
                <li>가중치가 부여된 알고리즘</li>
                <li>가중치(weighted) 라운드 로빈 알고리즘</li>
                <li>가중치 최소 연결 알고리즘</li>
                <li>서버 간 성능이 다른 경우<br> 
                    주로 가중치가 적용된 알고리즘 유리</li>
            <h4>포워드 프록시와 리버스 프록시</h4>    
            <h4>중간 서버와 다중화된 오리진 서버</h4>    
                <li>클라이언트와 일반적으로 단일<br> 
                    서버와 나란히 붙어 있지 않음</li>
                <li>실제로는 클라이언트와 서버 사이에는<br> 
                    수많은 서버가 존재할 수 있음</li>
                <li>실제로는 서버가 다중화된 경우가 많음</li>
                <li>기본에 단순히 서버라고 지칭했던 대상</li>
                <li>클라이언트가 최종적으로<br> 
                    메시지를 주고받는 대상</li>
                <li>자원을 생성하고 클라이언트에게<br> 
                    권한있는 응답을 보낼 수 있는<br> 
                    HTTP서버=오리진 서버(Origin server)</li>
                <li>인바운드(inbound)메시지:<br>
                    오리진 서버를 향하는 메시지</li>
                <li>아웃바운드(outbound)메시지:<br>
                    클라이언트를 향하는 메시지</li>
            <h4>대표적인 HTTP 중간 서버</h4>    
                <li>프록시(proxy):포워드(forward)프록시</li>
                <li>게인트웨이(gateway):리버스(reverse) </li>
            <h4>프록시(proxy)</h4>    
                <li>프록시:클라이언트가 선택한<br> 
                    메시지 전달 대리자</li>
                <li>프록시를 언제 어떻게 사용할지는<br> 
                    클라이언트가 선택</li>
                <li>오리진 서버보다 클라이언트와<br>
                    더 가까이 위치</li>
                <li>캐싱,클라이언트 암호화,접근 제한등</li>
            <h4>Gateway</h4>    
                <li>일반적의미:네트워크간의 통신을<br> 
                    가능케하는 입구 역할을 하는 HW/SW </li>
                <li>HTTP중간 서버 맥락에서의 의미</li>
                <li>아웃바운드 연결에 대해 오리진 서버<br> 
                    역할을 수행 하는 중개자</li>
                <li>수신된 요청 메시지를 다른 인바운드<br> 
                    서버(들)에 전달하는 중개자</li>
                <li>클라이언트가 보기에<br> 
                    오리진 서버와 같이 보임</li>
                <li>클라이언트 요청을 오리진 서버에<br> 
                    전달하기 위해 오리진 서버(들)에<br> 
                    더 가까이 위치</li>
                <li>캐싱,로드밸런싱</li>
                <li>다중화된 오리진 서버들의<br> 
                    네트워크를 대적택에 비유한다면</li>
                <li>프록시(포워드 프록시)는 클라이언트를<br> 
                    대신해 대적택에 심부름 가는 심부름꾼</li>
                <li>게이트웨이(리버스 프록시)는<br> 
                    대저택을 지키는 경비</li>
            <h4>안정성을 위한 기술2</h4>    
                <li>통신 과정에서 평문으로 메시지를<br> 
                    주고 받아도 괜찮을까</li>
                <li>메시지를 훔쳐보거나 가로채 변조 가능</li>
                <li>그래서 필요한 것이 암호와&복호화</li>
                <li>암호화(encrypt):원문데이터를<br> 
                    알아보기 어려운 형태로 변경하는 과정</li>
                <li>복호화(decrypt):암호화된 데이터를<br> 
                    원문 데이터로 되돌리는 과정</li>
                <li>안전한 데이터 송수신뿐만 아니라<br> 
                    인증서 기반의 검증도 가능하게 함</li>
            <h4>암호화와 복호화의 핵심은 키(Key)</h4>    
                <li>키에 수학적연산(=암호화 알고리즘)을<br> 
                    거치면 암호문 생성</li>
                <li>두가지방식이 있다</li>
                <li>대칭키 암호와</li>
                <li>비대칭키 암호화(=공개키 암호화)</li>
            <h4>대칭키 암호화<br>
                symmetric-key cryptography</h4>    
                <li>암호화와 복호화에<br> 
                    동일한 키를 사용하는 방식</li>
                <li>동일한 키를 사용하므로<br>
                    키가 유출되면 큰문제 발생</li>
                <li>따라서 당연하게도 키를<br> 
                    안전하게 상대방에 전달해야함</li>
                <li>어떻게 안전하게 상대방에게<br> 
                    키를 전달할까</li>
                <li>안전하게 키를 전달하는<br> 
                    방법이 있다면 굳이 대칭키를<br> 
                    암호화할 필요가 있나</li>
                <li>그냥 데이터자체를 안전한<br> 
                    방법으로 전달하면 되지 않을까</li>
                <li>그래서 등장한것이 비대칭키 암호화</li>
            <h4>비대칭 키 암호화<br>
                asymmetric-key cryptography</h4>    
                <li>공개키 암호화public-key cryptography</li>
                <li>암호화에 사용되는 키와<br> 
                    복호화에 사용되는 키가 다름</li>
                <li>한 쌍의 키(공개 키,개인 키)를 사용<br>
                    한 키로 암호화 다른키로 복호화</li>
                <li>공개 키를 알아도 개인키 유출 불가능<br> 
                    반대도 마찬가지</li>
                <li>암호화에만 사용되는 공개 키는<br> 
                    유출되어도 상관없다</li>
            <h4>A가 B에게 "hi" 전송</h4>    
                <li>A가 B의 공개키 요청</li>
                <li>B는 A에게 공개키 전달</li>
                <li>A는B의 공개키로 "hi"암호화</li>
                <li>암호화된 데이터 전달</li>
                <li>암호문이기에 제 3자가<br>
                    이를 보아도 이해할 수 업음</li>
                <li>B는 개인키로 복호화</li>
            <h4>대칭 키 암호화 방식 장단점</h4>    
                <li>장점:적은 부하로 빠른 암호화<br> 
                    및 복호화 수행가능</li>
                <li>단점:키를 안전하게 전송하기 어려움</li>
            <h4>공개 키 암호화 방식 장단점</h4>    
                <li>장점:안전한 키 공유 가능</li>
                <li>단점:높은 부하, 암호화 및 복호화 느림</li>
                <li>이둘을 같이 사용할 수는 없을까?</li>
            <h4>세션키(session key)</h4>    
                <li>대칭키를 공개키로 암호화하고 개인키로<br> 
                    암호화된 대칭키 복호화 한다면</li>
                <li>안전한 대칭키 공유 가능</li>
                <li>빠른 대칭키 기반 암호화/복호화 가능</li>
                <li>이렇게 활용되는 대칭키=세션키</li>
            <h4>인증서(certificate)</h4>    
                <li>무엇인가를 증명하기 위한 문서</li>
                <li>네트워크(인터넷)에서의 인증서=<br>
                    일반적으로 공개 키 인증서<br>
                    (public key certificate)</li>
                <li>공개키 인증서:공개키와 공개키의<br> 
                    유효성을 입증하기 위한 전자 문서</li>
                <li>인증기관(CA,certificate Authority)</li>
                <li>인증서의 발급,검증,저장과 같은<br> 
                    역할을 수행할 수 있는 공인 기관</li>
                <li>대표적인 인증 기관</li>
                <li>IdenTrust</li>
                <li>DigiCert</li>
                <li>GlobalSign등</li>
                <li>서명 값(signature)</li>
                <li>인증 기관(CA)의 인증 정보</li>
                <li>이 공개키 인증서는 진짜야 내가 보증할게</li>
                <li>클라이언트는 CA가 발급한 인증서의<br> 
                    서명 값을 바탕으로 인증서를 검증</li>
            <h4>서명 값 생성의 원리</h4>
                <li>인증서 내용에 대한 해시 값을</li>
                <li>CA의 개인키로 암호화하는 방식으로 생성</li>
                <li>CA는 이렇게 얻어낸 정보를<br> 
                    서명 값으로 삼아 클라이언트에게<br> 
                    인증서와 함께 전송</li>
                <li>해시 값:해시 함수를 적용시킨 결과값</li>
                <li>해시 함수란:<br>
                    임의의 길이의 데이터를 고정된<br> 
                    길이의 데이터로 변환하는 함수<br>
                    MD5,SHA-1,SHA-2등<br>
                    입력값에 민감:입력 데이터가 조그만<br> 
                    달라져도 완전히 다른 결과가 나옴</li>
                <li>데이터 변조 여부 검사에 사용</li>
                <li>보낼 데이터+데이터에 대한<br> 
                    해시값을 함께 전송</li>
                <li>수신자가 전달받은 데이터에<br> 
                    대한 해시 값을 직접 계산</li>
                <li>계산 결과를 전달받은 해시 값과 비교</li>
                <li>같은 값이 도출된다면?<br> 데이터
                    전송 도중 변조되거나<br> 
                    소실되지 않았다고 판단 </li>
            <h4>인증서 검증 과정</h4>    
                <li>서명 값과 인증서 분리</li>
                <li>서명 값을 CA의 공개키로<br> 
                    복호화 하여 인증서 내용에<br>
                    대한 해시 값을 얻음</li>
                <li>인증서 데이터에 대한<br>
                    해시 값을 직접 계산</li>
                <li>이를 복호화한 값과 비교</li>
                <li>디지털 서명(digital signature):<br>
                    개인키로 암호화된 메시지를 공개키로<br> 
                    복호화함으로써 신원을 증명하는 절차</li>
            <h4>HTTPS : SSL과TLS</h4>    
                <li>SSL(Secure Sockets Layer)<br>
                    TLS(Transport layer Security)</li>
                <li>인증과 암호화를 수행하는 프로토콜</li>
                <li>TLS는 SSL을 계승한 프로토콜:<br>
                    작동 과정은 큰 틀에서 보면 유사함</li>
                <li>초기SSL2.0과SSL3.0을거쳐<br> 
                    TLS1.0,1.1,1.2,1.3이 순차적으로 출시</li>
                <li>오늘날 자주 사용되는 버전TSL1.3</li>
                <li>HTTPS(HTTP over TLS)</li>
                <li>SSL/TLS를 사용하는 대표적인 프로토콜</li>
                <li>HTTPS는 HTTP 메시지의 안전한<br> 
                    송수신을 위해 개발된 프로토콜</li>
                <li>HTTPS의 송수신 단계</li>
                <li>TCP쓰리웨이 핸드 셰이크</li>
                <li>TLS 핸드 셰이크</li>
                <li>암호화된 메시지 송수신</li>
                <li>TLS 핸드 셰이크:<br>
                    암호화 통신을 위한 키 교환<br>
                    인증서 송수신과 검증이 이루어지는 단계</li>
                <li>TLS핸드셰이크 과정의 주요 메시지</li>
                <li></li>
            <h4>TLS핸드셰이크에서의 키 교환</h4>    
                <li>클라이언트의 ClientHello 메시지</li>
                <li>암호환된 통신을 위해 서로 맞춰<br> 
                    봐야 할 정보들을 제시하는 메시지</li>
                <li>지원TLS버전 사용 가능한 암호화<br> 
                    알고리즘과 해시 함수 키 생성에<br> 
                    필요한 난수등이 포함</li>
                <li>서버의 ServerHello메시지</li>
                <li>ServerHello메시지는 제시된<br>
                    정보들을 선택하는 메시지</li>
                <li>선택된 TLS버전 사용 가능한 암호화<br> 
                    알고리즘 과 해시 함수 키 생성에<br> 
                    필요한 난수 등이 포함</li>
                <li>ClientHello,ServerHello를<br>
                    주고 받으면 암호화 통신을 위해<br>
                    사전 협의해야 할 정보들이 결정됨</li>
                <li>서버와 클라이언트는 암호화에<br> 
                    사용할 키를 생성</li>
                <li>암호 스위트(cipher suite):<br>
                    사용 가능한 암호화 방식과<br>
                    해시 함수를 담은 정보</li>
            <h4>TLS핸드셰이크에서의<br>
                인증서 및 인증서 검증</h4>    
                <li>서버는 Certificate메시지와<br>
                    CertificateVerify메시지 전송</li>
                <li>각각 인증서와 검증을 위한 디지털 서명</li>
                <li>클라이언트는 이메시지를<br> 
                    토대로 서버의 공개 키 검증</li>
            <h4>TLS핸드셰이크 마무리,암호화 통신 수행</h4>    
                <li>서버와 클라이언트는 TLS핸드셰이크의<br>
                    마지막을 의미하는<br> 
                    Finished 메시지를 주고 받음</li>
                <li>이제 주고받은 키를 바탕으로 암호화<br>
                    데이터(Application Data)주고 받음</li>
            <h4>무선 네트워크</h4>    
                <li>연결 매체-전파</li>
                <li>표준-802.11/Wi-Fi</li>
                <li>장비-AP</li>
                <li>전파(radio wave):<br>
                    무선 네트워크의 연결 매체</li>
                <li>약3kHz부터 3THz사이의 진동수를<br> 
                    갖는 전자기파<br>
                    (눈에 보이지 않는 전자기파의 일종)</li>
                <li>서로 다른 전파 신호가 같은<br>
                    공간에 혼재할 수도 있음</li>
                <li>인위적/자연적으로 생성되고 관측</li>
                <li>자연적 전파(e.g.번개)에 의한 잡음</li>
            <h4>주파수 대역</h4>    
                <li>서로다른 전파신호를 구분할 수 있는 방법</li>
                <li>어떤 주파수 대역을 어떻게<br>
                    사용할지는 나라마다 다르다</li>
                <li>서로 다른 전파 신호를<br>
                    구분할 수 있도록 대역을 분배</li>
                <li>방송용 주파수,위성 통신용 주파수<br>    
                    항공/해양 통신을 위한 주파수등</li>
            <h4>와이파이와 802.11</h4>    
                <li>LAN환경에서의 무선 통신은<br> 
                    IEEE802.11로 표준화</li>
                <li>802.11b,802.11g처럼 숫자<br>
                    802.11뒤에 알파벳으로다양한 규격 표현</li>
                <li>IEEE802.11표준은 대부분<br>
                    2.4GHz, 5GHz대역을 사용</li>
                <li>무선 네트워크를 이용할때<br>
                    (와이파이를 선택할때)<br> 
                    2.4G/2.4GHz,5g/5GHz라는<br> 
                    글귀가 자주 보이는 이유</li>
                <li>IEEE 802.11버전에 따라 주파수<br>
                    전송속도,대역폭,<br>
                    전송가능거리등이 달라짐</li>
                <li>송수신속도:5GHz > 2.4GHz</li>
                <li>회절성(장애물의 영향):2.4GHz > 5GHz</li>
                <li>회절성:파동이 장애물이나 좁은<br> 
                    틈을 통과할때 파통이<br> 
                    그뒤 편까지 전파되는 현상</li>
                <li>장애물이 많다면 2.4GHz</li>
                <li>장애물이 적은 상황에서<br> 
                    속도가 필요하다면 5GHz</li>
            <h4>그렇다면 Wi-Fi는 무엇일까</h4>    
                <li>IEEE802.11표준을 따르는 무선 LAN기술</li>
                <li>본래는 와이파이 얼라이언스라는<br> 
                    비영리 단체의 트레이드 마크(브랜드)</li>
                <li>와이파이4,와이파이5등의 세대가 있고<br>
                    각 세대는 각기 다른<br>
                    IEEE802.11표준 규격을 준수</li>
                <li>인증마크역할을 하는 와이피이</li>
                <li>와이파이 인증 마크=해당 제품이<br> 
                    준수하는 특정IEEE802.11규격<br>
                    다른 제품과의 호환성<br></li>
                <li>무선 LAN제품을 개발한 회사는<br>
                    인증 시험을 거쳐 Wi-Fi인증과<br>
                    인증 로고 사용 권한 획득</li>
            <h4>같은 주파수 대역을 사용하는<br> 
                여러 무선 네트워크의 구분</h4>    
                <li>2.4GHz대역을 사용하는<br>
                    여러 네트워크 구분</li>
                <li>5GHz대역을 사용하는<br> 
                    여러 네트워크 구분</li>
                <li>채널(channel)</li>
                <li>주파수 대역은 채널(하위 주파수 대역)<br>
                    로 한 번 더 세분화되고 해당 채널 대역<br>
                    에서 통신이 이루어짐</li>
                <li>채널에는 번호가 할당(자동/수동)</li>
                <li>같은 공간에서 같은 대역의<br> 
                    서로 다른 네트워크를 구성하거나<br>
                    간섭없는 채널 권장</li>
                <li>무선 네트워크 속성에서 여러 정보 확인</li>
            <h4>AP(Access Point)</h4>    
                <li>무선 통신 기기들을 연결하여<br>
                    무선 네티워크를 구성하는 장치</li>
                <li>예:가정의 무선 공유기</li>
                <li>일반적으로 AP에는 유선 연결매체를<br> 
                    연결할 수 있는 지점도 함께 제공</li>
                <li>유선 네트워크와 무선네트워크의<br> 
                    연결을 담당 역할도 수행</li>
            <h4>AP와 서비스셋</h4>    
                <li>인프라스트럭처 모드<br>
                    (infrastructure mode)</li>
                <li>AP를 경유하여 통신이 이루어지는<br> 
                    무선 네트워크 통신 방식</li>
                <li>오늘날 많은 무선LAN이 AP가<br>
                    중개하는 인프라스트럭처 모로 동작</li>
                <li>애드 혹 모드(Ad Hoc mode):<br>
                    AP의 간섭없이 호스트간에<br> 
                    일대일로 통신하는 무선 통신 모드</li>
                <li>서비스셋:무선 네트워크를 이루는<br>
                    AP와 여러 장치들의 집합</li>
                <li>같은 서비스 셋에 속한 장치들은<br> 
                    같은 무선 네트워크에 속함</li>
            <h4>서비스셋 식별자<br>
                (SSID:Service Set Identifier)</h4>    
                <li>서비스셋을 구분짓는 수단</li>
                <li>무선 네트워크를 지칭하는 고유한 이름</li>
            <h4>비컨 프레임(beacon frame)</h4>    
                <li>AP는 불특정 다수 모두에게<br> 
                    자신을 알리는 브로드캐스트<br> 
                    메시지를 주기적으로전송</li>
                <li>비컨 프레임 안에는<br> 
                    SSID와 AP의 MAC주소등이 포함</li>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>