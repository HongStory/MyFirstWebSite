<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS part4</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network </a></li>
            <li><a href="page_network2.html"> NW part2 </a></li>
            <li><a href="page_network3.html"> NW part3 </a></li>
            <li><a href="page_network4.html"> NW part4 </a></li>
            <li><a href="page_network5.html"> NW part5 </a></li>
            <li><a href="page_network6.html"> NW part6 </a></li>
            <li><a href="page_network7.html"> NW part7 </a></li>

        </ol>
    </nav>
    
        <main>
            <h2>OS part4</h2>
            <ul>
            <h4>스래싱과 프레임 할당</h4>
                <li>페이지 폴트가 자주 발생하는 이유</li>
                <li>나쁜 페이지 교체 알고리즘을 사용해서</li>
                <li>프로세스가 사용할 수 있는<br>
                    프레임 자체가 적어서</li>
                
            <h4>스래싱</h4>    
                <li>프로세스가 실행되는 시간보다<br> 
                    페이징에 더 많은 신간을 소요하여<br>
                    성능(CPU이용률)이 저하되는 문제</li>
                <li>동시 실행되는 프로세스의 수를<br> 
                    늘린다고 CPU이용률이<br>
                    높아지는건 아니다</li>
                <li>각 프로세스가 필요로 하는 최소한의<br>
                    프레임 수가 보장되지 않았기 때문</li>
                <li>각 프로세스가 필요로 하는 최소한의<br>
                    프로세스를 파악하고 프로세스들에게<br>
                    적절한 프레임을 할당해주어야 한다</li>
            <h4>균등 할당</h4>    
                <li>가장 단순한 할당방식</li>
                <li>모든 프로세스들에게 균등하게<br>
                    프레임을 할당하는 방식</li>
            <h4>비례 할당</h4>    
                <li>프로세스의 크기를 고려하자</li>
                <li>프로세스 크기에 비례하여 프레임 할당</li>
                <li>정적 할당 방식</li>
                <li>실행해 보지 않으면 필요로하는<br>
                    프레임 수는 알 수가 없다</li>
                
            <h4>작업 집합 모델</h4>    
                <li>프로세스가 실행하는 과정에서<br>
                    배분할 프레임 결정</li>
                <li>스래싱이 발생하는 이유는<br>
                    빈번한 페이지 교체 때문</li>
                <li>그렇다면 CPU가 특정 시간 동안 주로<br>
                    참조한 페이지 개수만큼만<br>
                    프레임을 할당하면 된다</li>
                <li>프로세스가 일정 기간 동안<br>
                    참조한 페이지 집합을 기억하여<br>
                    빈번한 페이지 교체를 방지</li>
                <li>작업 집합이란 실행중인 프로세스가<br>
                    일정 시간 동안 참조한 페이지의 집합</li>
                <li>작업 집합 구하기</li>
                <li>프로세스가 참조한 페이지</li>
                <li>시간 간격 필요</li>
            <h4>페이지 폴트 빈도</h4>    
                <li>프로세스가 실행하는 과정에서<br>
                    배분할 프레임 결정</li>
                <li>두 개의 가정에서 생겨난 아이디어</li>
                <li>페이지 폴트율이 높으면 그 프로<br>
                    세스는 너무 적은 프레임을 갖고 있다</li>
                <li>페이지 폴트율이 낮으면 그 프로<br>
                    세스가 너무 많은 프레임을 갖고 있다</li>
                <li>페이지 폴트율이 상한선과 하한선을<br>
                    정하고 그 내부 범위 안에서만<br>
                    프레임을 할당하는 방식</li>
                <li>작업 집합 모델,페이지 폴트 빈도:<br>
                    동적 할당 방식</li>
                
            <h4>페이징의 이점 + 계층적 페이징</h4>    
                <li>이론적인 fork()</li>
                <li>프로세스는 기본적으로<br>
                    자원을 공유하지 않는다</li>
                <li>부모 프로세스가 적재된 별도의 공간에<br>
                    자식 프로세스가 통채로 복제되어 적재</li>
                <li>프로세스 생성 시간 지연,메모리 낭비</li>
                <li>쓰기식 복사</li>
                <li>부모 프로세스와 동일한 자식 프로세스가<br>
                    복제되어 생성되면 자식 프로세스는<br>
                    부모 프로세스와 동일한 프레임을 가리킴<br>
                    쓰기 작업이 없다면 이 상태 유지</li>
                <li>부모 프로세스/자식 프로세스 둘중<br>
                    하나가 페이지에 쓰기 작업 수행시<br>
                    해당 페이지는 별도의 공간으로 복제</li>
                <li>프로세스 생성 시간 절약, 메모리 절약</li>
            <h4>계층적 페이징</h4>    
                <li>프로세스 테이블의 크기는<br>
                    생각보다 작지 않다</li>
                <li>프로세스를 이루는 모든 페이지 테이블<br>
                    엔트리를 메모리에 두는 것은 큰 낭비</li>
                <li>프로세스를 이루는 모든 페이지 테이블<br>
                    엔트리를 항상 메모리에<br>
                    유지하지 않는 방법</li>
                <li>페이지 테이블을 페이징하여 여러<br>
                    단계의 페이지 테이블을 두는 방식</li>
                <li>계층적 페이징을 이용하는<br>
                    환경에서의 논리주소</li>
                <li>바깥 페이지번호</li>
                <li>안쪽 페이지 번호</li>
                <li>변위</li>
                <li>계층이 많다고해서 반드시 좋은것 아님</li>
            <h4>파일과 디렉터리</h4>
                <li>보조기억 장치의 데이터 덩어리</li>
                <li>파일 시스템</li>
                <li>파일과 디렉터리를 관리하는<br>
                    운영체제 내의 프로그램</li>
                <li>파일과 디렉터리를 다루는 프로그램</li>
                <li>파일:보조기억 장치에 저장된<br>
                    관련 정보의 집합</li>
                <li>의미 있고 관련있는 정보를<br>
                    모은 논리적 단위</li>
                <li>파일을 이루는 정보</li>
                <li>파일을 실행하기 위한 정보+<br>
                    부가 정보(속성,메타 데이터)</li>
                <li>속성:유형,크기,보호,생성날짜,<br>
                    마지막 접근날짜,마지막 수정날짜,<br>
                    생성자,소유자,위치,확장자</li>
                <li>파일 연산을 위한 시스템 호출</li>
                <li>파일생성,삭제,열기,닫기,읽기,쓰기</li>
            <h4>디렉터리</h4>
                <li>윈도우에서는 폴더</li>
                <li>1단계 디렉터리</li>
                <li>트리 구조 디렉터리</li>
                <li>최상위 디렉터리(루트디렉터리,/)</li>
                <li>윈도우에서는 C:₩,C:￥</li>
                <li>서브 디렉터리</li>
                <li>경로:디렉터리를 이용해 파일,<br>
                    디렉터리의 위치,나아가 이름까지<br>
                    특정 지을 수 잇는 정보</li>
                <li>절대 경로:루트 디렉터리부터 시작(/)</li>
                <li>상대 경로:현재 디렉터리부터 시작</li>
                <li>디렉터리 연산을 위한 시스템 호출</li>
                <li>디렉터리생성,삭제,열기,닫기,읽기</li>
                <li>운영체재는 파일과 디렉터리를<br>
                    구분짓지 않는다</li>
                <li>디렉터리 엔트리</li>
                <li>각 엔트리(행)에 담기는 정보</li>
                <li>디렉터리에 포함된 대상의 이름</li>
                <li>대상이 보조기억장치 내에 저장된 위치</li>
                <li>속성을 명시하는 경우도 있다</li>
                <li>파일 시스템 마다 다르다</li>
                <li>.. 상위 디렉터리</li>
                <li>. 현재 디렉터리</li>
            <h4>파일 시스템</h4>    
                <li>파일시스템이 파일과 디렉터리를<br>
                    보조기억장치에 할당하고<br>
                    접근하는 방법</li>
                <li>대표적인 파일 시스템의 종류</li>
                <li>FAT파일 시스템,유닉스 파일 시스템</li>
                <li>파티셔닝과 포멧팅</li>
                <li>막 공장에서 생산되어 한번도<br>
                    사용된 적이 없는 보조기억장치</li>
                <li>파티셔닝과 포맷팅을 해야 사용가능</li>
                <li>파티셔닝:저장 장치의 논리적인<br>
                    영역을 구획하는 작업</li>
                <li>포매팅:파일 시스템을 설정,<br>
                    어떤 방식으로 파일을 관리할지 결정<br>
                    새로운 데이터를 쓸 준비하는 작업</li>
                <li>파일 시스템에는 여러종류가 있고,<br>
                    파티션마다 다른 파일 시스템을<br>
                    설정할 수도 있다</li>
            <h4>파일 할당 방법</h4>    
                <li>포매팅까지 끝난 하드 디스크에<br>
                    파일 저장하기</li>
                <li>운영체제는 파일,디렉터리를 블록단위로<br>
                    읽고 쓴다 즉 하나의 파일이<br>
                    보조기억장치에 저장될 때에는 <br>
                    여러 블록에 걸처 저장된다</li>
                <li>연속 할당과 불연속할당</li>
                <li>불연속할당:연결 할당과 색인 할당</li>
            <h4>연속 할당:연속적인 블록에 파일 할당</h4>
                <li>연속된 파일에 접근하기 위해 파일의<br>
                    첫 번째 주소 블록 주소화 블록<br>
                    단위의 길이만 알면된다</li>
                <li>디렉터리 엔트리:파일이름,<br>
                    첫번째블록주소,블록단위길이 명시</li>
                <li>연속 할당은 외부 단편화 야기</li>
            <h4>연결 할당:각 블록의 일부에 다음<br>
                    블록의 주소를 저장하여 각블록이<br>
                    다음 블록을 가리키는 형태로 할당</h4>
                <li>파일을 이루는 데이터 블록을<br>
                    연결 리스트로 관리</li>
                <li>파일을 이루는 데이터 블록을<br>
                    연결 리스트로 관리</li>
                <li>파일이 여러 블록에 흩어져 저장가능</li>
                <li>디렉터리 엔트리에는<br>
                    파일이름,첫번째블록주소,블록단위길이</li>
                <li>첫번째블록주소와 마지막 블록주소</li>
                <li>반드시,첫번째부터 하나씩 읽어야해서<br>
                    접근속도가 매우느리다</li>
                <li>오류 발생시 해당 블록이후<br>
                    블록은 접근이 어렵다</li>
            <h4>색인 할당</h4>
                <li>파일의 모든 블록 주소를<br>
                    색인 블록 이라는 하나의<br>
                    블록에 모아 관리하는 방식</li>
                <li>파일 내 임의의 위치에 접근하기 용이</li>
                <li>디렉터리 엔트리:<br>
                    파일이름,색인블록주소</li>
            <h4>FAT파일 시스템</h4>    
                <li>연결 할당 기반 파일 시스템</li>
                <li>연결 할당의 단점을 보완</li>
                <li>각 블록에 포함된 다음 블록<br>
                    주소를 한데 모아 테이블로 관리</li>
                <li>FAT가 메모리에 캐시될 경우<br>
                    느린 임의 접근 속도 개선 가능</li>
                <li>예약+FAT+루트디렉터리+데이터</li>
                <li>디렉터리 엔트리</li>
                <li>파일이름,확장자,속성,예약,생성<br>
                    마지막접근,마지막수정,시작블록,크기</li>
            <h4>유닉스 파일 시스템</h4>    
                <li>색인 할당 기반 파일 시스템</li>
                <li>색인 블록==i-node</li>
                <li>파일의 속성 정보와 15개의<br>
                    블록 주소 저장 가능</li>
                <li>블록 주소중 12개에는<br>
                    직접 블록 주소 저장</li>
                <li>직접 블록:파일 데이터가 저장된 블록</li>
                <li>12개로 충분하지 않다면 13번째에<br>
                    주소에 단일 간접 블록 주소 저장</li>
                <li>단일 간접 블록:파일 데이터를<br>
                    저장한 블록 주소가 저장된 블록</li>
                <li>13번째로도 충분 하지 않다면<br>
                    14번째 주소에 이중 간접<br> 
                    블록 주소 저장</li>
                <li>이중 간접 블록:단일 간접<br>
                    블록들의 주소를 저장하는 블록</li>
                <li>14번째로도 충분하지 않다면<br>
                    삼중 간접 블록 주소 저장</li>
                <li>상중 간접 블록:이중 간접<br>
                    블록들의 주소를 저장하는 블록 </li>
                <li>디렉터리 엔트리</li>
                <li>i-node가 파일 시스템의 핵심</li>
                <li>파일 이름외에 모든 정보를 가진다</li>
            <h4>NTFS 파일 시스템</h4>
                <li>윈도우에서 사용됨</li>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>