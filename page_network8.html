<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part8</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp" alt=""/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript2.html"> JavaScript</a></li>
            <li><a href="page_javascript.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_datastr.html"> Data-Structure </a></li>
            <li><a href="page_cs1.html"> CS知識1 </a></li>
            <li><a href="page_cs2.html"> CS知識2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network-OSI model </a></li>
            <li><a href="page_network2.html"> Physical-Data-layer1 </a></li>
            <li><a href="page_network3.html"> Physical-Data-layer2 </a></li>
            <li><a href="page_network4.html"> Network-layer1 </a></li>
            <li><a href="page_network5.html"> Network-layer2 </a></li>
            <li><a href="page_network6.html"> Transport-layer </a></li>
            <li><a href="page_network7.html"> Application-layer1 </a></li>
            <li><a href="page_network8.html"> Application-layer2 </a></li>
            <li><a href="page_network9.html"> Application-layer3 </a></li>
            <li><a href="page_network10.html"> Application-layer4 </a></li>
            <li><a href="page_network11.html"> Application-layer5 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Application-layer2</h2>
            <ul>
            <h4>응용계층 HTTP</h4> 
                <li>사용자와 밀접하게<br> 
                    맞닿아 있는 프로토콜</li>
                <li>웹 세상의 기반이 되는<br> 
                    가장 중요한 프로토콜</li>
                <li>HTTP의 네가지 중요한 특성<br>
                </li>
                <li>요청-응답기반 프로토콜:<br>
                    클라이언트-서버구조 기반의<br> 
                    요청-응답 프로토콜<br>
                    HTTP요청 메시지와 함께 HTTP응답<br> 
                    메시지는 메시지 형태가 다름<br>
                    웹 브라우저의 개발자도구에서<br>
                    Network탭 클릭->특정사이트 접속</li>
                <li>미디어 독립적 프로토콜:<br>
                    HTTP를 정의한 공식문서(RFC910)<br>
                    HTTP가 요청한 대상은 자원이다<br>
                    HTTP는 자원의 특성을 제한하지않으며<br>
                    자원과상호작용하는 데 사용할 수 있는<br>
                    인터페이스(수단,통로)를 정의할 뿐이다<br>
                    대부분의 자원은 URI로 식별된다<br>
                    HTML,JPEG,PNG,JSON,XML,PDF등<br>
                    다양한 종류의 자원 송수신 가능<br>
                    미디어타입:HTTP에서 메시지를 <br>
                    주고받는 자원의 종류,웹세상의<br> 
                    확장자 즉,HTTP는 주고받을 미디어<br>
                    타입에 특별히 제한을<br>
                    두지 않고 동작하는<br> 
                    미디어 독립적 프로토콜<br>
                    미디어 타입의 구성과 종류:<br>
                    슬래시를 기준으로 타입/서브타입<br> 
                    형식으로 구성<br>
                    타입:데이터 유형<br>
                    서브타입:주어진 타입에 대한 세부 유형<br>
                    미디어 타입에는 부가적인 설명을 위해<br> 
                    선택적으로 매개변수 포함 가능<br>
                    타입/서브타입;매개변수=값<br>
                    의 형식으로 표현<br>
                    type/subtype;parameter=value<br>
                    예:type/html; charset=UTF-8<br>
                    미디어 타입의 종류는 매우 다양,<br>
                    새로운 미디어타입을 등록할 수도 있음<br>
                    (사이트 참조)<br>
                    text/* 텍스트 타입의 모든 서브타입<br>
                    image/* 이미지 타입의 모든 서브타입<br>
                    */* 모든 미디어 타입</li>
                <li>상태를 유지하지 않는 프로토콜:<br>
                    스테이트리스 프로토콜<br>
                    HTTP는 상태를 유지하지 않는<br> 
                    스테이트리스 프로토콜<br>
                    서버가 HTTP 요청을 보낸<br> 
                    클라이언트와 관련된 상태를<br> 
                    기억하지 않는다는 의미<br>
                    클라이언트의 모든 HTTP요청은<br> 
                    기본적으로 독립적인 요청으로 간주<br>
                    HTTP는 왜 상태를 유지 하지 않을까<br>
                    HTTP서버는 일반적으로 많은<br> 
                    클라이언트와 동시에 상호작용<br>
                    모든 클라이언트의 상태 정보를<br> 
                    유지하는 것은 서버에 큰 부담<br>
                    특정 클라이언트가 특정 서버에<br> 
                    종속되는 상황 방지<br>
                    HTTP가 상태를 유지하는 프로토콜<br>
                    이라면 클라이언트는 자신의 상태를<br> 
                    기억하는 특정 서버하고만 통신<br>
                    확장성과 견고성:<br>
                    HTTP가 처음 만들어 졌을때부터<br>
                    오늘날까지 이어지는 중요한 설계 목표<br>
                    상태를 유지하지 않는 특성은 특정<br> 
                    클라이언트가 특정 서버에 종속되지<br> 
                    않게함으로써 서버에 문제가 생겨도<br> 
                    다른 서버로 대체 용이<br> 
                    따라서 확장성,견고성에 유리</li>
                <li>지속 연결을 지원하는 프로토콜:<br>
                    비지속 연결:초기의 HTTP버전(1.0이하)<br>
                    TCP연결 수립한후,요청에 대한<br> 
                    응답을 받으면 연결 종료<br>
                    추가적인 요청-응답을 하기 위해서는<br> 
                    다시 TCP연결 수립부터 반복    
                </li>
                <li>지속 연결또는 킵 얼라이브:<br>
                    최근 대중적으로 사용되는<br> 
                    HTTP버전(1.1이상) 하나의<br> 
                    TCP연결상에서 여러개의 요청-<br>
                    응답을 주고 받을수 있는 기술
                </li>
            <h4>HTTP의 메시지 구조(v1.1)</h4>    
                <li>시작 라인,필드라인,<br>
                    메시지 본문으로 구성</li>
                <li>필드라인은 없거나<br> 
                    여러개 있을 수 있음</li>
                <li>메시지 본문은 없을 수 있음</li>
                <li>필드 라인과 메시지 본문<br> 
                    사이에는 빈 줄 바꿈이 있음</li>
                <li>HTTP메시지=<br>
                    시작라인(줄바꿈)<br>
                    필드라인(줄바꿈)(0개이상)<br>
                    (줄바꿈)<br>
                    메시지 본문(선택적) 
                </li>
            <h4>시작라인:<br>
                    요청라인(요청)과 상태라인(응답)</h4>
                <li>요청라인=메서드(공백)요청대상(공백)<br>
                    HTTP버전(줄바꿈)</li>
                <li>메서드:클라이언트가 서버의 자원<br>
                    (요청대상)에 대해 수행할 작업의 종류<br>
                    대표로 GET,POST,PUT,DELETE등</li>
                <li>요청대상:HTTP요청 보낼 서버의 자원<br>
                    보통(query 포함된)URI의 경로 명시<br>
                    예:클라이언트가 아래로 요청<br>
                    http://www.example.com<br>
                    /hello?q=world 이게 요청대상<br>
                    하위 경로가 없더라도 /로 표기<br>
                    http://www.example.com으로 요청<br>
                    요청대상은 /</li>
                <li>HTTP버전:HTTP/1.1형식으로 표기</li>
            <h4>상태라인</h4>    
                <li>상태라인=HTTP버전(공백)<br>
                    상태코드(공백)<br>
                    이유구문(줄바꿈)(선택적)</li>
                <li>상태코드:요청에 대한 결과를<br> 
                    나타내는 세자리 정수</li>
                <li>이유구문:상태코드에 대한<br>
                    문자열 형태의 설명</li>
                <li>HTTP/1.1 200 OK</li>
                <li>HTTP/1.1 404 Not Found</li>
            <h4>필드 라인 또는 헤더라인</h4>
                <li>0개 이상의 HTTP헤더 명시</li>
                <li>HTTP헤더:HTTP통신에<br> 
                    필요한 부가 정보</li>
                <li>콜론(:)을 기분으로 헤더이름과<br>
                    하나 이상의 헤더값으로 구성</li>
                <li>HOST:www.example.com</li>
                <li>User-Agent:Mozilla/5.0</li>
                <li>Accept:text/html</li>
            <h4>메시지 본문</h4>    
                <li>HTTP요청 혹은 응답 메시지에서<br>
                    본문이 필요할 경우 선택적으로<br>
                    메시지 본문에 명시</li>
                <li>다양한 콘텐츠 타입이 사용 가능</li>
            <h4>HTTP메서드 정리</h4>
                <li>GET:자원을 습득하기 위한 메서드</li>
                <li>HEAD:GET과 동일하나,<br>
                    헤더만을 응답받는 메서드</li>
                <li>POST:서버로 하여금 특정 작업을<br>
                    처리하게끔 하는 메서드</li>
                <li>PUT:자원을 대체하기 위한 메서드</li>
                <li>PATCH:자원에 대한 부분적<br> 
                    수정을 위한 메서드</li>
                <li>DELETE:자원 삭제를 위한 메서드</li>
                <li>CONNECT:자원에 대한 양방향<br> 
                    연결을 시작하려는 메서드</li>
                <li>OPTION:사용가능한 메서드등<br>
                    통신 옵션을 확인하는 메서드</li>
                <li>TRACE:자원에대한 루프백<br> 테스트를
                    수행하는 메서드</li>
            <h4>GET</h4>    
                <li>GET:가져다주세요<br>
                    특정 자원을 조회할때 사용되는 메서드<br>
                    (웹브라우저URL입력)<br>
                    클라이언트가 서버에게<br> 
                    이것을 가져다주세요<br>
                    라고 요청을 보내는 것과 같음<br>
                    이것:HTML,JSON,이미지파일등</li>
                <li>클라이언트가 아래와 같이 GET요청</li>
                <li>http://www.example.com<br>
                    /example-page</li>
                <li>요청 메시지는 아래와 같다</li>
                <li>GET /example-page HTTP/1.1<br>
                    Host: www.example.com<br>
                    Accept: *</li>
                <li>GET요청 메시지는 쿼리 문자열이<br> 
                    사용되는 경우가 많음</li>
                <li>GET /index.html?name1=value1<br>
                    &name2=value2 HTTP/1.1<br>
                    Host: www.example.com<br>
                    Accept: *</li>
                <li>응답메시지</li>
                <li>GET요청메시지가 성공적으로 처리<br> 
                    되었다면 이에대한 응답으로서<br> 
                    요청한 자원을 전달 받음</li>
                <li>HTTP/1.1 200 OK<br>
                    Content-Type: text/html<br>
                    Content-Length: 1234<br>
                    (공백)<br>
                    HTML본문내용</li>
            <h4>HEAD</h4>    
                <li>헤더만 가져다 주세요<br>
                    HEAD메서드를 사용하면 서버는<br> 
                    요청에 대한 응답으로 응답메시지의<br>
                    헤더만을 반환</li>
                <li>HEAD /example-page HTTP/1.1<br>
                    Host: www.example.com<br>
                    Accept: *</li>
                <li>HTTP/1.1 200 OK<br>
                    Content-Type: text/html<br>
                    Content-Length: 1234<br>
                    (여기까지 헤드만)</li>        
            <h4>POST</h4>    
                <li>POST처리해주세요<br>
                    서버로 하여금 특정 작업을<br> 
                    처리하도록 요청하는 메서드</li>
                <li>클라이언트의 입력 폼 작성 뒤<br>
                    게시하기 버튼 클릭 가정</li>
                <li>처리할 대상은 흔히 <br>
                    메시지 본문으로 명시</li>
                <li>POST /posting HTTP/1.1<br>
                    Host: example.com<br>
                    헤더 후락<br>
                    (공백)<br>
                    {<br>
                        "ID":1,<br>
                        "Title":"좋은 날씨",<br>
                        "Contents":"내용"<br>
                    }JSON형식의 본문</li>
                <li>많은 경우 클라이언트가 서버에<br> 
                    새로운 자원을 생성하고자 할때 사용<br>
                    새로운 자원이 생성시 서버는 응답<br> 
                    메시지의 Location헤더를 통해 새로<br>
                    생성된 자원의 위치를 알려줌</li>
                <li>HTTP/1.1 201 Created<br>
                    Contents-Type: application/json<br>
                    content-Length:100<br>
                    Date: Mon, 14 Oct 2024<br>
                    16:35:00 PST<br>
                    Location: /posting/1<br>
                    (공백)<br>  
                    {<br>
                        내용<br>
                    }</li>
            <h4>PUT</h4>    
                <li>PUT덮어써 주세요</li>
                <li>요청 자원이 없다면 메시지<br> 
                    본문으로 자원을 새롭게 생성</li>
                <li>요청 자원이 존재한다면 메시지<br> 
                    본문으로 자원을 완전히 대체</li>
            <h4>PATCH</h4>    
                <li>일부를 수정해 주세요</li>
                <li>부분적 수정</li>
                <li>메시지 본문에 맞게 자원 일부 수정</li>
            <h4>DELETE</h4>    
                <li>삭제해 주세요</li>
                <li>특정 자원을 삭제하고 싶을대 사용</li>
                <li>DELETE /texts/a.txt HTTP/1.1<br>
                    Host: example.com</li>
            <h4>개발자 입장에서 생각해보는<br>
                HTTP 메서드</h4>
                <li>어떤URI(URL)에 어떤 메서드로<br> 
                    요청 받았을 때 서버는 어떻게<br> 
                    행동해야 할까? 이 설계는 오로지<br>
                    개발자의 몫 이다</li>
                <li>어떤 메서드는 구현 할수도 있고<br>
                    어떤 메서드는 구현하지 않을 수도 있다</li>
                <li>같은 URL에 대해 메서드별 동작을<br> 
                    여러개 구현할 수도 있음</li>
            <h4>HTTP 상태코드</h4>    
                <li>상태코드는 요청에 대한 결과를<br> 
                    나타내는 세자리 정수</li>
                <li>상태 코드의 종류는 백의 자리<br> 
                    수를 기준으로 유형을 구분</li>
                <li>100번대(100~199):정보성 상태코드</li>
                <li>200번대(200~299):성공 상태코드</li>
                <li>300번대(300~399):리다이렉션 </li>
                <li>400번대(400~499):클라이언트 에러 </li>
                <li>500번대(500~599):서버에러 상태코드</li>
            <h4>200번대:성공 상태 코드</h4>    
                <li>요청이 성공했음을 의미</li>
                <li>주요 상태코드</li>
                <li>200(OK):요청이 성공했음</li>
                <li>201(Created):요청 잘 받고<br>
                    새로운 자원이 생성됨</li>
                <li>202(Accepted):요청받았으나 아직<br> 
                    작업 안 끝남</li>
                <li>204(No Content):요청 성공했으나<br>
                    메시지 본문으로 표시할 데이터가 없음</li>
            <h4>300번대:리다이렉션 상태코드</h4>    
                <li>리다이렉션:요청을 완수하기 위해<br> 
                    추가적인 조치가 필요한 상태</li>
                <li>클라이언트가 요청한 자원이 다른<br> 
                    곳에 있을때 클라이언트의 요청을<br>
                    다른 곳으로 이동 시키는 것</li>
                <li>영구적인 리다이렉션:<br>
                    자원이 완전히 새로운 곳으로<br> 
                    이동하여 경로가 영구적으로 재지정<br>
                    이 경우 기존의 URL에 요청 메시지를<br> 
                    보내면 항상 새로운 URL로 리다이렉트
                </li>
                <li>301:Moved Permanently<br>
                    영구적 리다이렉션<br>
                    재요청 메서드 변경될 수 있음<br>
                    POST로 요청 후 GET으로 재요청</li>
                <li>308:Permanently Redirect<br>
                    영구적 리다이렉션<br>
                    재요청 메서드 변경되지 않음<br>
                    POST로 요청했으면 POST로 재요청</li>
                <li>일시적인 리다이렉션</li>
                <li>자원의 위치가 임시로 변경되었거나<br> 
                    임시로 사용할 URL이 필요한<br> 
                    경우에 주로 사용 어떤 URL에 대해<br> 
                    일시적인 리다이렉션 관련 상태<br> 
                    코드를 응답받았다면 여전히<br>
                    요청을 보낸 URL은 기억</li>
                <li>302:Found 일시적 리다이렉션<br>
                    재요청 메서드 변경될 수 있음</li>
                <li>303:See Other 일시적 리다이렉션<br>
                    재요청 메서드 GET으로 변경</li>
                <li>307:Temporary Redirect 일시적<br>
                    리다이렉션 재요청 메시지<br> 
                    변경되지 않음</li>
            <h4>400번대:클라이언트 에러</h4>    
                <li>클라이언트에 의한 에러가<br> 
                    있음을 알려주는 상태코드</li>
                <li>400:Bad Request<br>
                    클라이언트의 요청이 잘못되었음</li>
                <li>401:Unauthorized<br>
                    요청한 자원에 대한<br>
                    유효한 인증이 없음</li>
                <li>403:Forbidden 요첨이 서버에<br>
                    의해 거부됨(권한이 없을 경우)</li>
                <li>404:Not Found<br>
                    요청받은 자원을 찾을 수 없음<br>
                    존재하지만 공개되지 않은 자원에<br>
                    대해404로 응답하는 경우도 있음</li>
                <li>405:Method Not Allowed<br>
                    요청한 메서드를 지원하지 않음</li>
            <h4>500번대:서버에러 관련</h4>    
                <li>클라이언트가 올바르게 요청을<br> 
                    보냈을지라도 발생할 수 있는<br> 
                    서버 에러에 대한 상태코드</li>
                <li>500:Internal Server Error<br>
                    서버의 예기치 못한 상황으로<br> 
                    인해 요청을 처리할 수 없음<br>
                    상태 코드500은 서버 내 에러를 통칭</li>
                <li>502:Bad Gateway 클라이언트와<br>
                    서버 사이에 위치한 중간 서버의<br>
                    통신 오류를 나타내는 상태 코드<br>
                    중간 서버가 유효하지 않거나<br> 
                    잘못된 응답을 받을 때</li>
                <li>503:Service Unavailable<br>
                    현재 서비스를 일시적으로<br>
                    이용할 수 없음 서버가 과부하<br> 
                    상태에 있거나 일시적인 점검<br> 
                    상태일 때 볼 수 있는 상태</li>
            <h4>HTTP의 발전</h4>    
                <li>HTTP/0.9 현재는 거의 사용되지<br> 
                    않는 초창기 버전 사용가능한 메서드<br>
                    GET 헤더 지원 안함</li>
                <li>HTTP/1.0 HEAD,POST등 GET이외의<br>
                    메서드 도입 헤더 지원 시작<br>
                    공식적으로는 지속 연결 미지원</li>
                <li>HTTP/1.1 오늘날 까지 널리<br> 
                    사용되는 버전 지속 연결 공식적 지원<br>
                    파이프라이닝,콘텐츠 협상 기능등<br>
                    다양한 편의 기능 추가<br>
                    메시지 본문=평문</li>
                <li>HTTP1.1까지는 고질족 문제가 있음<br>
                    HOL(Head Of Line)블로킹:<br>
                    같은 큐에 대기하며<br> 
                    순차적으로 처리되는 여러<br> 
                    패킷이 있을 경우 첫 번째 패킷의<br> 
                    처리 지연으로 인해 나머지 패킷<br> 
                    처리도 모두 지연되는 문제 상황 </li>
                <li>HTTP/2.0오늘날 까지 널리 사용<br>
                    HTTP/1.1의 효율과 성능을<br> 
                    높이기 위한 버전<br>
                    메시지 본문=바이너리 데이터<br>
                    헤더 압축 전송 기능<br>
                    서버 푸시 기능<br>
                    클라이언트가 요청하지 않았더라도<br> 
                    미래에 필요할 것으로 예상되는<br> 
                    자원 미리 전송하는 기능<br>
                    HTTP멀티 플랙싱을 통한<br> 
                    HOL블록킹 완화<br>
                    여러 스트림을 활용해 병렬적으로<br> 
                    메시지를 주고받는 기술<br>
                    요청-응답 단위는 하나의<br> 
                    스트림에서 이루어짐<br>
                    스트림별 독립적인 송수신 가능<br>
                    별도의 스트림을 통해 여러<br> 
                    데이터를 병렬적으로 주고 받으며<br>
                    HOL블록킹 완화</li>
            <h4>HTTP/3.0<br>
                오늘날 점차 사용 확대되는 버전</h4>    
                <li>이전까지의 HTTP버전=TCP기반 동작</li>
                <li>HTTP/3.0=UDP기반 프로토콜인 QUIC<br>
                    Quick UDP Internet Connection<br>
                    기반으로 동작<br> 
                    연결형 프로토콜 기반 송수신 속도<br>
                    보다 빠른 비연결형 프로토콜<br> 
                    기반 송수신 속도로 빠른 송수신 가능</li>
            <h4><a href="page_network9.html"> Application-layer3 </a></h4>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>