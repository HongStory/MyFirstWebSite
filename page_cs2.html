<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>컴퓨터 구조 파트2</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network </a></li>
            <li><a href="page_network2.html"> NW part2 </a></li>
            <li><a href="page_network3.html"> NW part3 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>컴퓨터 구조 파트2</h2>
            <ul>
            <h4>빠른 CPU를 위한 설계기법</h4>
                <li>클럭</li>
                <li>코어,멀티코어</li>       
                <li>스레드,멀티스레드</li>
                <li>스레드:실행 흐름의 단위</li>
                <li>하드웨어 스레드=논리 프로세서</li>
                <li>하나의 코어가 동시에<br> 처리하는 명령어 단위</li>
                <li>1코어 1스레드</li>
                <li>2코어 4스레드</li>
                <li>소프트웨어 스레드:<br>하나의 프로그램에서 <br>독립적으로 실행되는 단위</li>
                <li>1코어1스레드라도<br> 여러개의 소프트웨어<br>스레드를 만들수 있다</li>
                <li>스레드와 멀티 스레드</li>
                <li>레지스터 세트가 여러개가 있으면<br>동시에 여러개를 처리할 수 있다</li>
            
            <h4>명령어 병렬처리 기법</h4>
                <li>CPU가 어떻게하면 시간을 알뜰하게<br> 쓰며 명령어들을 처리 할수 있을까</li>
                <li>명령어 파이프라인</li>
                <li>명령어 인출</li>
                <li>명령어 해석</li>
                <li>명령어 실행</li>
                <li>결과 저장</li>
                <li>같은 단계가 겹치지만 않는다면<br>각 단계를 동시에 실행할 수 있다</li>
                <li>파이프라인 위험</li>
                <li>명령어 파이프라인이 <br>성능 향상에 실패하는 경우</li>
                <li>데이터 위험</li>
                <li>모든 명령어를 동시에 처리할 수 없다</li>
                <li>하나의 명령어를 끝내야 다음 명령어를 <br>실행 할수 있는 경우</li>
                <li>제어 위험</li>
                <li>프로그램 카운터의 갑작스러운 변화</li>
                <li>구조적 위험</li>
                <li>서로 다른 명령어가<br> 같은 부품을 사용하려 할때</li>
                
            <h4>슈퍼 스칼라</h4>
                <li>CPU내부에 여러개의 명령어 파이프 라인</li>
                <li>늘어난다고 반듯이 빨라지지는 않는다</li>
            
            <h4>비순차적 명령어 처리</h4>
                <li>아무 명령어가 순서를 바꿀 수 없다</li>
            
            <h4>명령어 집합</h4>
                <li>CPU마다 명령어의 생김새,연산,<br>주소지정방식 등은CPU마다 다르다</li>
                <li>CPU가 이해할 수 있는<br> 명령어들의 모임</li>
                <li>명령어가 달라지면<br> 그에 대한 나비효과로<br>많은것이 달라진다</li>    
                <li>명령어의 해석 방식</li>    
                <li>레지스터의 종류와 개수</li>    
                <li>파이프라이닝의 용이성</li>    
                <li>ISA는 CPU의 언어이자 하드웨어가<br>소프트웨어를 어떻게 이해할지<br>
                    에 대한 약속이다</li>
            
            <h4>명령어 집합의 두축 </h4>
                <li>CISC</li>
                <li>complex instruction set computer</li>    
                <li>x86,x86-64는 <br>CISC 기반 명령어 집합 구조</li>
                <li>상대적으로 적은 수의 명령어로도 <br>프로그램을 실행할 수 있다</li>
                <li>명령어 파이프라이닝이 불리하다</li>
                <li>가변 길이 명령어</li>
                <li>다양한 주소 지정 방식</li>
                <li>여러 클럭에 걸쳐 명령어 수행</li>

                <li>RISC</li>
                <li>reduced instruction set computer</li>
                <li>명령어의 종류가 적고,짧고 규격화됨</li>
                <li>메모리 접근 최소화,<br>레지스터 십분 활용</li>
                <li>고정 길이 명령어</li>
                <li>적은 주소 지정방식</li>
                <li>프로그램을 이루는 명령어의 수가 많음</li>
                <li>1클럭 내외로 명령어 수행</li>
                <li>파이프라이닝하기 쉬움</li>

            <h4>램의 특성과 종류</h4>
                <li>실행할 대상을 저장</li>
                <li>전원이 꺼지면 내용 삭제</li>
                <li>휘발성 저장장치</li>
                <li>램의 용량과 성능</li>
                <li>무조건 크다고 좋은건 아니지만 좋다</li>
                <li>램의 종류</li>
                <li>DRAM:Dynamic RAM</li>
                <li>저장된 데이터가 동적으로<br> 사라지는 램</li>
                <li>데이터 소멸을 막기위해<br> 주기적으로 재활성화 해야함</li>
                <li>일반적으로 메모리로 사용되는 램</li>
                <li>소비전력이 낮고 저렴 집적도가 높음</li>
                <li>SRAM:Static RAM</li>
                <li>저장된 데이터가 정적인<br>(사라지지 않은)램</li>
                <li>DRAM보다 일반적으로 빠름</li>
                <li>일반적으로 캐시 메모리에서 사용</li>
                <li>소비전력이 높고 가격이<br> 높고 집적도 낮음</li>
                <li>대용량으로 설계할 필요없는<br> 빨라야하는 장치</li>
                <li>SDRAM:Synchronous DRAM</li>
                <li>특별한(발전된 형태의)DRAM</li>
                <li>클럭 신호와 동기화된 DRAM</li>
                <li>DDR SDRAM:Double Data Rate SDRAM</li>
                <li>특별한(발전된 형태의)SDRAM</li>
                <li>최근 가장 대중적으로 사용하는 RAM</li>
                <li>대역폭을 넓혀 속도를 빠르게 만든 SDRAM</li>
            
            <h4>메모리의 주소공간</h4>    
                <li>논리주소 와 물리주소</li>
                <li>CPU와 실행중인 프로그램은<br> 메모리 몇 번지에 무엇이 <br>
                    저장되어 있는지 다 알지 못한다</li>
                <li>메모리에 저장된 값들은<br> 시시각각 변함</li>
                <li>물리주소</li>
                <li>메모리 입장에서 바라본 주소</li>
                <li>논리 주소</li>
                <li>CPU와 실행중인 프로그램<br> 입장에서 바라본 주소</li>
                <li>실행중인 프로그램 각각에게<br> 부여된 0번지부터 시작하는 주소</li>
                <li>물리주소와 논리주소의 변환</li>
                <li>CPU->(논리주소)-><br>MMU(메모리관리장치)
                    <br>->(물리주소)->메모리</li>
                <li>논리주소+베이스레지스터값<br>=물리주소</li>
                <li>메모리 보호</li>
                <li>한계(리미트) 레지스터</li>
                <li>CPU는 메모리에 접근하기전<br>
                    접근하고자 하는 논리 주소가 한계 <br>
                    레지스터보다작은지를 항상 검사</li>
            
            <h4>캐쉬 메모리</h4>
                <li>CPU가 메모리에 접근하는시간은<br>
                    CPU연산 속도보다 느리다</li>
                <li>저장장치 계층구조</li>
                <li>CPU와 가까운 저장 장치는 빠르고<br>멀리 있는 장치는 느리다</li>
                <li>속도가 빠른 저장 장치는<br> 비싸고 용량이 적다</li>
                <li>레지스터>캐쉬메모리><br>메모리>USB메모리</li>
                <li>캐쉬메모리</li>
                <li>CPU와 메모리 사이에 위치한<br>
                    레지스터보다 용량이 크고 메모리보다<br>
                    빠른 SRAM기반의 저장 장치</li>
                <li>CPU의 연산 속도와 메모리 접근<br> 속도의
                    차이를 조금이나마<br> 줄이기위해 탄생</li>
                <li>CPU가 사용할 일부 데이터를 미리<br>
                    캐시 메모리로 가지고 와서 쓰자</li>
                <li>계층적 캐시 메모리</li>
                <li>속도는L1>L2>L3</li>
                <li>L1,L2는CPU코어 내부에<br> L3는외부에 위치</li>
                <li>분리형 캐시 메모리</li>
                <li>L1 -> L1D,L1I</li>
                <li>캐시 메모리는 메모리보다 용량이 작다</li>
                <li>CPU가 자주 사용할 법한<br> 내용을 예측저장</li>
                <li>캐시 히트:예측 성공</li>
                <li>캐시 미스:예측 불발</li>
                <li>캐시 적중률을 높여야한다</li>
                <li>참조 지역성의 원리</li>
                <li>CPU는 최근에 접근했던 <br>메모리 공간에 
                    다시 접근하려는<br> 경향이 있다</li>
                <li>CPU는 접근한 메모리 공간 근처를<br>
                    접근하려는 경향이 있다</li>
            
            <h4>보조기억장치</h4>    
                <li>전원이 꺼져도 데이터 유지</li>
                <li>하드디스크:자기적인 방식으로 저장</li>
                <li>스핀들,플래터,헤드,디스크암</li>
                <li>섹터,트랙,블록,실린더</li>
                <li>하드디스크가 데이터에 접근하는 시간</li>
                <li>탐색시간,회전지연,전송시간</li>
                <li>플래시 메모리</li>
                <li>전기적으로 데이터를 읽고 쓰는<br>반도체 기반 저장장치</li>
                <li>NAND 플래시 메모리</li>
                <li>NOR 플래시 메모리</li>
                <li>셀(CELL)</li>
                <li>플래시 메모리에서 데이터를<br> 저장하는 가장 작은 단위</li>
                <li>셀이 모이고 모여<br> 수MB,GB,TB가 된다</li>
                <li>1bit:SLC,2bit:MLC,<br>3bit:TLC,4bit:QLC</li>
                <li>셀-페이지-블록-플레인-다이</li>
                <li>플레시 메모리는 덮어쓰기 불가능</li>
                <li>가비지 컬렉션</li>
                <li>유효한 페이지들만을<br> 새로운 블록으로 복사</li>
                
            <h4>RAID의 정의와 종류</h4>    
                <li>하드디스크와 SSD로 사용하는 기술</li>
                <li>데이터의 안전성 혹은 높은 성능을<br> 
                    위해 여러 물리적 보조기억장치를<br>
                    마치 하나의 논리적 보조기억장치처럼<br> 사용하는 기술</li>
                <li>RAID0,RAID1,RAID4,<br>RAID5,RAID6</li>
                <li>스트라입,스트라이핑</li>
                <li>미러링:복사본을 만드는 방식</li>
                <li>패리티 비트:오류를 검출하는 정보</li>
                
            <h4>장치 컨트롤러와 장치 드라이버</h4>
                <li>CPU,메모리보다 다루기가 까다롭다</li>
                <li>종류가 너무 많아 규격화가 어렵다</li>
                <li>데이터 전송률이 낮아 느림</li>
                <li>장치 컨트롤러는 하드웨어</li>
                <li>장치 컨트롤러로 내부와<br> 정보를 주고 받는다</li>
                <li>CPU와 입출력장치 간의 통신중개</li>
                <li>오류 검출</li>
                <li>데이터 버퍼링</li>
                <li>버퍼링:전송률이 높은 장치와<br> 
                    낮은 장치 사이에 주고 받는<br>
                    데이터를 버퍼라는 임시 저장 공간에<br>
                    저장하여 전송률을 <br>비슷하게 맞추는 방법</li>
                <li>장치 컨트롤러의 구조</li>
                <li>데이터 레지스터</li>
                <li>CPU와 입출력장치 사이에 주고받을<br>
                데이터가 담기는 레지스터(버퍼)</li>
                <li>RAM을 사용하기도</li>
                <li>상태 레지스터</li>
                <li>상태 정보 저장</li>
                <li>입출력장치가 작업을 할<br> 준비가 되었는지</li>
                <li>입출력 작업이 완료되었는지</li>
                <li>오류는 없는지 등의 상태정보</li>
                <li>제어 레지스터</li>
                <li>입출력장치가 수행할 내용에<br> 대한 제어 정보</li>
                <li>버스에 연결 된다</li>
            
            <h4>장치 드라이버</h4>    
                <li>장치 컨트롤러의 동작을<br> 감지하고 제어하는 프로그램</li>
                <li>입출력장치를 연결하기<br> 위한 소프트웨어적인 통로</li>
                <li>장치드라이버가 설치되어 있지 않다면<br>
                해당 입출력장치는 사용할 수 없습니다</li>
                
            <h4>다양한 입출력 방법</h4>    
                <li>프로그램 입출력</li>
                <li>프로그램 속 명령어로<br> 입출력장치를 제어하는 방법</li>
                <li>입출력 명령어로써<br> 장치 컨트롤러와 상호작용</li>
                <li>CPU가 장치 컨트롤러의 레지스터<br>
                    값을 읽고 씀으로써 이루어진다</li>
                <li>메모리 맵 입출력 방식</li>
                <li>고립형 입출력 방식</li>
                <li>인터럽트 기반 입출력</li>
                <li>PIC:우선순위를 판단</li>
                <li>DMA 입출력</li>
                <li>CPU를 거치지 않고 입출력장치가<br>
                메모리에 직접적으로 접근하는 기능</li>
                <li>DMA컨트롤러</li>
                <li>CPU가 시스템버스를 이용하지 않을때<br>
                조금씩 시스템버스를 이용</li>
                <li>입출력 전용 버스에 연결</li>
                <li>PCI버스,PCI express버스</li>
                
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>