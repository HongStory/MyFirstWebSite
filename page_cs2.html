<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>컴퓨터 구조 파트2</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_cs3.html"> 구조파트3 </a></li>
            <li><a href="page_os.html"> OS </a></li>
            <li><a href="page_network.html"> Network </a></li>
        </ol>
    </nav>
    
         <main>
            <h2>컴퓨터 구조 파트2</h2>
            <ul>
            <h4>빠른 CPU를 위한 설계기법</h4>
                <li>클럭</li>
                <li>코어,멀티코어</li>       
                <li>스레드,멀티스레드</li>
                <li>스레드:실행 흐름의 단위</li>
                <li>하드웨어 스레드=논리 프로세서</li>
                <li>하나의 코어가 동시에<br> 처리하는 명령어 단위</li>
                <li>1코어 1스레드</li>
                <li>2코어 4스레드</li>
                <li>소프트웨어 스레드:하나의 프로그램에서 <br>독립적으로 실행되는 단위</li>
                <li>1코어1스레드라도 여러개의 소프트웨어<br>스레드를 만들수 있다</li>
                <li>스레드와 멀티 스레드</li>
                <li>레지스터 세트가 여러개가 있으면<br>동시에 여러개를 처리할 수 있다</li>
            
            <h4>명령어 병렬처리 기법</h4>
                <li>CPU가 어떻게하면 시간을 알뜰하게<br> 쓰며 명령어들을 처리 할수 있을까</li>
                <li>명령어 파이프라인</li>
                <li>명령어 인출</li>
                <li>명령어 해석</li>
                <li>명령어 실행</li>
                <li>결과 저장</li>
                <li>같은 단계가 겹치지만 않는다면<br>각 단계를 동시에 실행할 수 있다</li>
                <li>파이프라인 위험</li>
                <li>명령어 파이프라인이 <br>성능 향상에 실패하는 경우</li>
                <li>데이터 위험</li>
                <li>모든 명령어를 동시에 처리할 수 없다</li>
                <li>하나의 명령어를 끝내야 다음 명령어를 <br>실행 할수 있는 경우</li>
                <li>제어 위험</li>
                <li>프로그램 카운터의 갑작스러운 변화</li>
                <li>구조적 위험</li>
                <li>서로 다른 명령어가 같은 부품을 사용하려 할때</li>
                
            <h4>슈퍼 스칼라</h4>
                <li>CPU내부에 여러개의 명령어 파이프 라인</li>
                <li>늘어난다고 반듯이 빨라지지는 않는다</li>
            
            <h4>비순차적 명령어 처리</h4>
                <li>아무 명령어가 순서를 바꿀 수 없다</li>
            
            <h4>명령어 집합</h4>
                <li>CPU마다 명령어의 생김새,연산,<br>주소지정방식 등은CPU마다 다르다</li>
                <li>CPU가 이해할 수 있는 명령어들의 모임</li>
                <li>명령어가 달라지면 그에 대한 나비효과로<br>많은것이 달라진다</li>    
                <li>명령어의 해석 방식</li>    
                <li>레지스터의 종류와 개수</li>    
                <li>파이프라이닝의 용이성</li>    
                <li>ISA는 CPU의 언어이자 하드웨어가<br>소프트웨어를 어떻게 이해할지<br>
                    에 대한 약속이다</li>
            
            <h4>명령어 집합의 두축 </h4>
                <li>CISC</li>
                <li>complex instruction set computer</li>    
                <li>x86,x86-64는 <br>CISC 기반 명령어 집합 구조</li>
                <li>상대적으로 적은 수의 명령어로도 <br>프로그램을 실행할 수 있다</li>
                <li>명령어 파이프라이닝이 불리하다</li>
                <li>가변 길이 명령어</li>
                <li>다양한 주소 지정 방식</li>
                <li>여러 클럭에 걸쳐 명령어 수행</li>

                <li>RISC</li>
                <li>reduced instruction set computer</li>
                <li>명령어의 종류가 적고,짧고 규격화됨</li>
                <li>메모리 접근 최소화,레지스터 십분 활용</li>
                <li>고정 길이 명령어</li>
                <li>적은 주소 지정방식</li>
                <li>프로그램을 이루는 명령어의 수가 많음</li>
                <li>1클럭 내외로 명령어 수행</li>
                <li>파이프라이닝하기 쉬움</li>

            <h4>램의 특성과 종류</h4>
                <li>실행할 대상을 저장</li>
                <li>전원이 꺼지면 내용 삭제</li>
                <li>휘발성 저장장치</li>
                <li>램의 용량과 성능</li>
                <li>무조건 크다고 좋은건 아니지만 좋다</li>
                <li>램의 종류</li>
                <li>DRAM:Dynamic RAM</li>
                <li>저장된 데이터가 동적으로 사라지는 램</li>
                <li>데이터 소멸을 막기위해<br> 주기적으로 재활성화 해야함</li>
                <li>일반적으로 메모리로 사용되는 램</li>
                <li>소비전력이 낮고 저렴 집적도가 높음</li>
                <li>SRAM:Static RAM</li>
                <li>저장된 데이터가 정적인<br>(사라지지 않은)램</li>
                <li>DRAM보다 일반적으로 빠름</li>
                <li>일반적으로 캐시 메모리에서 사용</li>
                <li>소비전력이 높고 가격이 높고 집적도 낮음</li>
                <li>대용량으로 설계할 필요없는<br> 빨라야하는 장치</li>
                <li>SDRAM:Synchronous DRAM</li>
                <li>특별한(발전된 형태의)DRAM</li>
                <li>클럭 신호와 동기화된 DRAM</li>
                <li>DDR SDRAM:Double Data Rate SDRAM</li>
                <li>특별한(발전된 형태의)SDRAM</li>
                <li>최근 가장 대중적으로 사용하는 RAM</li>
                <li>대역폭을 넓혀 속도를 빠르게 만든 SDRAM</li>
            
            <h4>메모리의 주소공간</h4>    
                <li>논리주소 와 물리주소</li>
                <li>CPU와 실행중인 프로그램은<br> 메모리 몇 번지에 무엇이 <br>
                    저장되어 있는지 다 알지 못한다</li>
                <li>메모리에 저장된 값들은 시시각각 변함</li>
                <li>물리주소</li>
                <li>메모리 입장에서 바라본 주소</li>
                <li>논리 주소</li>
                <li>CPU와 실행중인 프로그램<br> 입장에서 바라본 주소</li>
                <li>실행중인 프로그램 각각에게<br> 부여된 0번지부터 시작하는 주소</li>
                <li>물리주소와 논리주소의 변환</li>
                <li>CPU->(논리주소)-><br>MMU(메모리관리장치)
                    <br>->(물리주소)->메모리</li>
                <li>논리주소+베이스레지스터 값=물리주소</li>
                <li>메모리 보호</li>
                <li>한계(리미트) 레지스터</li>
                <li>CPU는 메모리에 접근하기전<br>
                    접근하고자 하는 논리 주소가 한계 <br>
                    레지스터보다작은지를 항상 검사</li>
            
            <h4>캐쉬 메모리</h4>
                <li>CPU가 메모리에 접근하는시간은<br>
                    CPU연산 속도보다 느리다</li>
                <li>저장장치 계층구조</li>
                <li>CPU와 가까운 저장 장치는 빠르고<br>멀리 있는 장치는 느리다</li>
                <li>속도가 빠른 저장 장치는<br> 비싸고 용량이 적다</li>
                <li>레지스터>캐쉬메모리>메모리>USB메모리</li>
                <li>캐쉬메모리</li>
                <li>CPU와 메모리 사이에 위치한<br>
                    레지스터보다 용량이 크고 메모리보다<br>
                    빠른 SRAM기반의 저장 장치</li>
                <li>CPU의 연산 속도와 메모리 접근 속도의<br>
                    차이를 조금이나마 줄이기위해 탄생</li>
                <li>CPU가 사용할 일부 데이터를 미리<br>
                    캐시 메모리로 가지고 와서 쓰자</li>
                <li>계층적 캐시 메모리</li>
                <li>속도는L1>L2>L3</li>
                <li>L1,L2는CPU코어 내부에 L3는외부에 위치</li>
                <li>분리형 캐시 메모리</li>
                <li>L1 -> L1D,L1I</li>
                <li>캐시 메모리는 메모리보다 용량이 작다</li>
                <li>CPU가 자주 사용할 법한 내용을 예측저장</li>
                <li>캐시 히트:예측 성공</li>
                <li>캐시 미스:예측 불발</li>
                <li>캐시 적중률을 높여야한다</li>
                <li>참조 지역성의 원리</li>
                <li>CPU는 최근에 접근했던 메모리 공간에<br> 
                    다시 접근하려는 경향이 있다</li>
                <li>CPU는 접근한 메모리 공간 근처를<br>
                    접근하려는 경향이 있다</li>
            
            <h4>보조기억장치</h4>    
                <li>전원이 꺼져도 데이터 유지</li>
                <li>하드디스크:자기적인 방식으로 저장</li>
                <li>스핀들,플래터,헤드,디스크암</li>
                <li>섹터,트랙,블록,실린더</li>
                <li>하드디스크가 데이터에 접근하는 시간</li>
                <li>탐색시간,회전지연,전송시간</li>
                <li>플래시 메모리</li>
                <li>전기적으로 데이터를 읽고 쓰는<br>반도체 기반 저장장치</li>
                <li>NAND 플래시 메모리</li>
                <li>NOR 플래시 메모리</li>
                <li>셀(CELL)</li>
                <li>플래시 메모리에서 데이터를<br> 저장하는 가장 작은 단위</li>
                <li>셀이 모이고 모여 수MB,GB,TB가 된다</li>
                <li>1bit:SLC,2bit:MLC,3bit:TLC,4bit:QLC</li>
                <li>셀-페이지-블록-플레인-다이</li>
                <li>플레시 메모리는 덮어쓰기 불가능</li>
                <li>가비지 컬렉션</li>
                <li>유효한 페이지들만을 새로운 블록으로 복사</li>
                
            <h4>RAID의 정의와 종류</h4>    
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>