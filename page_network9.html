<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part9</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
                        <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_datastr.html"> Data-Structure </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network-OSI model </a></li>
            <li><a href="page_network2.html"> Physical-Data-layer1 </a></li>
            <li><a href="page_network3.html"> Physical-Data-layer2 </a></li>
            <li><a href="page_network4.html"> Network-layer1 </a></li>
            <li><a href="page_network5.html"> Network-layer2 </a></li>
            <li><a href="page_network6.html"> Transport-layer </a></li>
            <li><a href="page_network7.html"> Application-layer1 </a></li>
            <li><a href="page_network8.html"> Application-layer2 </a></li>
            <li><a href="page_network9.html"> Application-layer3 </a></li>
            <li><a href="page_network10.html"> Application-layer4 </a></li>
            <li><a href="page_network11.html"> Application-layer5 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Application-layer3</h2>
            <ul>
            <h4>HTTP헤더와 HTTP 기반기술</h4>
            <h4>HTTP헤더</h4>    
                <li>필드 이름(헤더이름)과<br> 
                    필드값(헤더값)이 콜론(:)을<br> 
                    기준으로 구분</li>
                <li>헤더 유형<br>
                    특별한 사전 지식이 필요하지 않은 헤더<br>
                    사전 지식이 필요한 헤더<br>
                    예:캐시,쿠키,콘텐츠 협상 관련 헤더</li>
            <h4>Host</h4>    
                <li>요청을 보낼 호스트를 나타내는 헤더</li>
                <li>주로 도메인 네임 명시<br>
                    포트 번호가 포함되어 있을 수있 음</li>
                <li>예:http://info.cern.ch/hypertext<br>
                    /WWW/TheProject.html에<br> 
                    접속할때의 HTTP요청 메시지 일부</li>
                <li>GET /hypertext/WWW<br>
                    /TheProject.html HTTP/1.1<br>
                    Host: info.cern.ch</li>
            <h4>User-Agent</h4>    
                <li>유저 에이전트:HTTP요청을 시작하는<br> 
                    클라이언트 측의 프로그램<br>
                    (예:웹브라우저)</li>
                <li>User-Agent헤더:요청 메시지<br> 
                    생성에관여한 클라이언트 프로그램과<br> 
                    관련된 다양한 정보가 명시</li>
            <h4>Referer</h4>    
                <li>클라이언트가 요청을 보낼 때<br> 
                    머무르고 있던 URL이 명시</li>
                <li>클라이언트의 유입 경로를 파악</li>
                <li>Referer: https://en.wikipedia.org/</li>
            <h4>Authorization</h4>    
                <li>클라이언트의 인증 정보를 담는 헤더</li>
                <li>인증 타입과 인증을 위한 정보 명시</li>
                <li>Authorization:<br>
                    &lt;type&gt; &lt;credentials&gt;</li>
                <li>인증 타입에 따라 인증<br> 
                    정보에 명시될 값이 달라짐</li>
                <li>가장 기본적인 HTTP인증 타입은Basic</li>
                <li>username:password를<br>
                    base64인코딩한 값을 인증<br> 
                    정보로 삼는 방식</li>
                <li>예:사용자아이디가apple<br>
                    비밀번호는1234일 경우<br>
                    apple:1234을<br>
                    Base64로 인코딩한<br>
                    blWluY2h1bDoxMjM0이런코드로인증</li>
                <li>Authorization:<br> 
                    Basic blWluY2h1bDoxMjM0</li>
            <h4>Server</h4>    
                <li>요청을 처리하는 서버 측의<br> 
                    소프트웨어와 관련된 정보를 명시</li>
                <li>예:Unix운영체제에서 동작하는<br> 
                    아파치HTTP서버를 의미하는 헤더</li>
                <li>Server: Apache/2/4/1 (Unix)</li>
            <h4>Allow</h4>    
                <li>클라이언트에게 허용된 HTTP메서드<br> 
                    목록을 알려 주기 위해 사용</li>
                <li>상태 코드405를 응답하는 메시지에서<br>
                    Allow헤더가 함께 사용</li>
            <h4>Retry-After</h4>    
                <li>상태코드503과 함께 사용될 수 있는 헤더</li>
                <li>자원을 사용할 수 있는 날짜<br>
                    혹은 시각을 나타냄</li>
                <li>Retry-After: Fri,<br> 
                    23 Aug 2024 09:00:00 GMT<br>
                    Retry-After: 120</li>
                <li>예:2024년8월23일 금요일<br>
                    09시 이후에 사용 가능함</li>
                <li>예:120초 이후에 사용 가능함</li>
                <li>현재는 요청을 처리할 수 없으나<br>
                    추후 가능할 수도 있음</li>
            <h4>Location</h4>    
                <li>클라이언트에게 자원의 위치를<br> 
                    알려 주기 위해 사용되는 헤더</li>
                <li>주로 리다이렉션이 발생했을 때나<br> 
                    새로운 자원이 생성되었을 때 사용</li>
            <h4>WWW.Authenticate</h4>    
                <li>상태 코드401(Unauthorized)과<br> 
                    함께사용되는 헤더</li>
                <li>자원에 접근하기 위한 인증 방식을 설명</li>
                <li>www-Authenticate: Basic</li>
            <h4>Authorization과WWw.Authenticate<br> 
                헤더를 통한 HTTP 인증(Basic인증)과정</h4>    
                <li>1.인증되지 않은 클라이언트가<br> 
                    서버에 GET요청 메시지를 전송</li>
                <li>2.서버는401과 함께<br> 
                    WWW.Authenticate헤더를 통해<br> 
                    인증 방식을 알림</li>
                <li>3.클라이언트는 사용자로부터<br> 
                    인증 정보(사용자 아이다와 비밀번호)<br>
                    를 전달받음</li>
                <li>4.클라이언트는 Base64인코딩한 값을<br> 
                    Authorization헤더를 통해<br> 
                    요청 메시지를 전송</li>
                <li>서버는 인증 정보를 확인</li>
                <li>인증이 유효하면 상태코드 200으로<br> 
                    응답하고 인증되지 않았으면<br> 
                    상태코드 401로 응답</li>
            <h4>요청과 응답 모두에서<br>
                활용되는 HTTP헤더</h4>    
            <h4>Date</h4>    
                <li>메시지가 생성된 날짜와 시각에<br> 
                    관련된 정보를 닯은 헤더</li>
                <li>Date: tue, 15 Nov 1994 08:12:31 GMT</li>
            <h4>Connection</h4>    
                <li>클라이언트의 요청과 응답 간의<br> 
                    연결 방식을 설정하는 헤더</li>
                <li>지속 연결이 Connection에<br>
                    명시되는 대표적인 연결 방식</li>
                <li>가장 대표적으로 사용되는 값은<br>
                    Keep-alive와 close</li>
                <li>Connection: Keep-alive</li>
                <li>Connection: close</li>
            <h4>Content-length</h4>    
                <li>본문의 바이트 단위 크기(길이)</li>
                <li>Content-length: 100</li>
            <h4>표현 헤더(representation header):<br>
                메시지 본문의 표현 방식을 설명하는 헤더</h4>
            <h4>Content-Type</h4>    
                <li>메시지 본문에서 사용된 미디어 타입</li>
            <h4>Content-Language</h4>    
                <li>메시지 본문에 사용된 자연어를 명시</li>
                <li>언어 태크로 명시:<br>
                    하이픈(-)으로 구분된 구조</li>
                <li>일반적으로 첫번째 서브태크=언어코드<br>
                    두번째 서브태크=국가코드</li>
                <li>언어 코드<br>
                    한국어:ko<br>
                    영어:en<br>
                    중국어:zh<br>
                    일본어:ja<br>
                    독일어:de<br>
                    프랑스어:fr</li>
                <li>국가 코드<br>
                    한국:KR<br>
                    미국:US<br>
                    영국:GB<br>
                    중국:CN<br>
                    타이완:TW<br>
                    일본:JP<br>
                    독일:DE<br>
                    프랑스:FR</li>
                <li>언어코드-국가코드의 조합</li>
                <li>어떤 국가에서 사용하는 어떤 언어</li>
                <li>ko-KR</li>
                <li>en-GB</li>
                <li>en-US</li>
            <h4>Content-Encoding</h4>    
                <li>메시지 본문을 압축하거나 변환한 방식</li>
                <li>Content-Encoding: gzip </li>
                <li>Content-Encoding: compress</li>
                <li>Content-Encoding: deflate</li>
                <li>Content-Encoding: br</li>
                <li>여러 인코딩이 사용되었을 경우<br>
                    적용된 순서대로 명시</li>
                <li>Content-Encoding: deflate,gzip </li>
            <h4>HTTP 기반 기술</h4>    
            <h4>캐시</h4>
                <li>응답 받은 자원의 사본을<br> 
                    임시 저장하는 기술</li>
                <li>추후 동일한 요청에 대해 캐시된<br>
                    데이터를 활용할 수 있음</li>
                <li>불필요한 대역폭 낭비 방지<br>
                    응답 지연 방지</li>
                <li>빠른 자원 접근 가능</li>
                <li>개인 전용 캐시(private cache)<br>
                    웹브라우저에 저장</li>
                <li>공용 캐시(public cache)<br>
                    클라이언트와 서버 사이에 위치한<br> 
                    중간 서버에 저장</li>
            <h4>캐시 신선도의 검사와 유지</h4>    
                <li>핵심은 사본을 저장한다는 점</li>
                <li>캐시된 데이터는 얼마든지<br> 
                    원본 데이터와 달라질 수 있다</li>
                <li>캐시 신선도(cache freshness)</li>
                <li>캐시된 사본 데이터가 얼마나 최신<br>
                    원본 데이터와 유사한지를 표현</li>
                <li>어떻게 캐시 신선도를 검사할 수 있을까</li>
            <h4>캐시 신선도 검사:유효 기간 설정</h4>    
                <li>기간이 만료되었다면<br> 
                    원본 데이터를 다시 요청</li>
                <li>유효 기간 설정 방법</li>
                <li>응답 메시지의 Expires 헤더(날짜)와<br>
                    Cache-Control 헤더의<br>
                    Max-Age값(초)을 사용</li>
                <li>예:캐시의 유효 시간을<br> 
                    2024년 2월 6일 화요일 12:00:00로 설정<br>
                    또는 1200초로 설정하는 응답 메시지</li>
                <li>Expires:<br> 
                    Tue, 06, Feb 2024 12:00:00 GMT</li>
                <li>Cache-Control: max-age=1200</li>
            <h4>캐시 신선도의 재검사</h4>    
                <li>If-Modified-Since헤더</li>
                <li>날짜를 기반으로 서버에게 물어보는 방법</li>
                <li>If-Modified-Since헤더에 명시된<br> 
                    시점 이후로 원본에 변경이 있었다면<br> 
                    그때만 새 자원으로 응답하도록<br> 
                    서버에게 요청하는 헤더</li>
                <li>If-Modified-Since:<br>
                    Fri, 23 Aug 2024 09:00:00 GMT</li>
                <li>위 날짜 이후로 변경이 되었다면<br> 
                    새 자원으로 응답하라</li>
            <h4>서버의 Last-Modified 헤더</h4>    
                <li>상태코드 304(Not Modified)를<br> 
                    통한 자원의 변경 여부 뿐만 아니라<br>
                    자원이 마지막으로 수정된<br> 
                    시점도 알려줄 수 있음</li>
            <h4>If-Not-Match헤더</h4>    
                <li>엔티티 태그(Etag)를 기반으로<br> 
                    서버에게 물어보는 방법 </li>
                <li>Etag는 자원의 버전을 식별하기위한 정보</li>
                <li>버전이란 유의미한 변경 사항</li>
                <li>즉 자원이 변경 될 때마다 자원의<br> 
                    버전을 식별하는 Etag값이 변경</li>
                <li>반대로 자원이 변경되지 않았다면<br> 
                    Etag값도 변하지 안는다</li>
                <li>이 Etag값과 일치하는 자원이 있는가?<br>
                    혹시 Etag값이 abc인<br> 
                    www.example.com/index.html<br>
                    이라는 자원이 있는가?</li>
                <li>자원이 변경 되었다면<br>
                    (Etag값이 바뀌었다면)<br>
                    그때만 새자원으로 응답하라
                    </li>
                <li>GET /index.html HTTP/1.1<br>
                    Host: www.example.com<br>
                    If-None-Match: "abc"
                </li>
            <h4>쿠키(cookie)</h4>    
                <li>HTTP는 상태를 유지하지 않는<br> 
                    스테이트리스한 프로토콜</li>
                <li>서버에서 생성되어 클라이언트<br> 
                    측에 저장되는 데이터</li>
                <li>상태를 유지하지 않는 HTTP의<br> 
                    특성을 보완하기 위한 수단</li>
                <li>기본적으로 "이름,값" 쌍의 형태<br>
                    추가로 다양한 속성을 가질 수 있음</li>
                <li>서버는 쿠키를 생성하여<br> 
                    클라이언트에게 전송</li>
                <li>클라이언트는 전달받은 쿠키를<br> 
                    저장해 두엇다가 추후 요청 메시지에<br> 
                    쿠키를 포함하여 전송</li>
                <li>요청이 같은 클라이언트에서 왔는지<br>   
                    로그인 상태를 유지하고 있는지<br>
                    등을 알 수 있음</li>
            <h4>쿠키(cookie)를 활용하는<br>
                인증 기술, 세션 인증</h4>
                <li>HTTP는 스테이트리스 프로토콜</li>
                <li>같은 클라이언트가 서버에 여러 번<br>
                    요청을 보낸다고 해도 기본적으로 서버는<br> 
                    모든 요청들을 별개의 요청으로 간주</li>
                <li>클라이언트가 서버에 요청 메시지를<br> 
                    보낼 때마다(아아디,비빌번와같은)<br>
                    인증 정보를 보내고 번거로운<br> 
                    인증 과정을 거쳐야 하는 것일까?</li>
            <h4>세션 아이디와 세션 인증<br>
                (session id,session authentication)</h4>    
                <li>1.클라이언트는 서버에게<br>
                    (아이디,비밀번호와같은)<br>
                    인증 정보를 전송</li>
                <li>2.인증정보가 올바르다면 서버는 세션<br> 
                    아이디를 생성해 클라이언트에게 전송</li>
                <li>3.서버는 생성한 세션아이디를<br> 
                    데이터베이스 등에 저장</li>
                <li>4.클라이언트는 추후 요청을<br>
                    보낼 때 쿠키 내에 세션<br> 
                    아이디를 포함하여 전송</li>
                <li>5.서버는 쿠키 속 세션 아이디와<br> 
                    저장된 세션 아이디를 비교하여<br> 
                    클라이언트를 식별</li>
                <li>요청을 보낼 때마다 번거로운<br> 
                    인증 과정을 거칠 필요가 없음</li>
            <h4>서버의 쿠키 생성-<br>
                클라이언트의 쿠키 활용</h4>
                <li>응답 메시지의 Set-Cookie헤더<br>
                    요청 메시지의 Cookie헤더 활용</li>
            <h4>응답 메시지의 Set-Cookie헤더</h4>    
                <li>쿠키의 이름,값과 더불어 세미콜론(;)<br>
                    으로 구분되는 속성(들)을 전달</li>
                <li>한 응답 메시지에 전달할 쿠키가<br>
                    여러 개라면 다음과 같이<br> 
                    여러 개의 Set-Cookie</li>
                <li>응답 메시지<br>
                    Set-Cookie: 이름=값<br>
                    Set-Cookie: 이름=값; 속성1<br>
                    Set-Cookie: 이름=값; 속성1; 속성2<br>
                </li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            <h4><a href="page_network10.html"> Application-layer4 </a></h4>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>