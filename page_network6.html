<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part6</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network </a></li>
            <li><a href="page_network2.html"> NW part2 </a></li>
            <li><a href="page_network3.html"> NW part3 </a></li>
            <li><a href="page_network4.html"> NW part4 </a></li>
            <li><a href="page_network5.html"> NW part5 </a></li>
            <li><a href="page_network6.html"> NW part6 </a></li>
            <li><a href="page_network7.html"> NW part7 </a></li>
            <li><a href="page_network8.html"> NW part8 </a></li>
            <li><a href="page_network9.html"> NW part9 </a></li>
            <li><a href="page_network10.html"> NW part10 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Network part6</h2>
            <ul>
            <h4>정적 라우팅과 동적 라우팅</h4>
                <li>정적 라우팅과 동적 라우팅은<br> 
                    IP주소를 할당하는 방법과 유사</li>
                <li>정적 라우팅:수동으로 구성된 라우팅<br> 
                    테이블 항목을 통해 수행되는 라우팅</li>
                <li>동적 라우팅:자동으로 라우팅 테이블 <br>
                    항목을 만들고 이를 이용하여 라우팅</li>
                <li>정적 라우팅(static routing)<br>
                    사용자가 수동으로 직접 채워 넣은<br> 라우팅
                    테이블의 항목을 토대로 라우팅<br>
                    예시:10.0.0.0/24로 향하는 패킷을<br>
                    192.168.1.1게이트웨이로 정적 라우팅<br>
                    윈도우:> route add 10.0.0.0 mask<br>
                    255.255.255.0 192.168.1.1</li>
                <li>맥OS:$ sudo route add -net<br>
                    10.0.0.0/24 192.168.1.1</li>
                <li>리눅스:$ sudo route add -net<br> 
                    10.0.0.0 netmask 255.255.255.0<br> 
                    gw 192.168.1.1</li>
                <li>시스코 라우터:# ip route 10.0.0.0<br>
                    255.255.255.0 192.168.1.1</li>
                <li>동적 라우팅:네트워크의 규모가<br> 
                    커지고 관리해야 할 라우터가<br> 
                    늘어나면 정적 라우팅만으로는<br> 
                    관리가 힘듦 입력 실수가 발생함<br>
                    입력 실수가 없도 라우팅 경로상에<br>
                    예상치 못한 문제가 발생할 경우<br> 
                    경로 우회가 어려움</li>
                <li>자동으로 라우팅 테이블 항목을 만들고<br>
                    이를 이용하여 라우팅,라우팅 프로토콜<br>
                    이용 라우터끼리 자신들의 정보를<br> 
                    교환하며 패킷이 이동할 최적의경로를<br> 
                    찾기 위한 프로토콜,동적 라우팅을 하면<br> 
                    라우팅 테이블 항목이 수시로 변할 수<br> 
                    있음 라우팅 테이블의 항목을 수동으로<br> 
                    입력할 필요 없음,네트워크 경로상에<br> 
                    문제가 발생했을 때 이를 우회할 수<br> 
                    있게 경로가 자동으로 갱신</li>
            <h4>라우터들의 집단 네트워크<br>
                AS(Autonomous System)</h4>    
                <li>동적 라우팅과 라우팅 프로토콜을<br> 
                    이해하기 위한 배경지식</li>
                <li>한 회사나 단체에서 관리하는<br>
                    라우터 집단</li>
                <li>AS마다 인터넷상에서 고유한<br> 
                    AS번호(ASN)가 할당</li>
                <li>AS번호는 사설 IP주소처럼 사설<br> 
                    AS번호도 있지만 일반적으로<br> 
                    AS번호는 고유한 AS번호를 지칭 </li>
            <h4>라우팅 프로토콜</h4>    
                <li>라우터끼리 자신들의 정보를<br> 
                    교환하며 패킷이 이동할 최적의<br> 
                    경로를 찾기 위한 프로토콜</li>
                <li>라우팅 프로토콜의 종류</li>
                <li>IGP(Interior Gateway Protocol)<br>
                    AS내부에서 수행(예:RIP,OSPF)</li>
                <li>EGP(Exterior Gateway Protocol)<br>
                    AS외부에서 수행(예:BGP)</li>
                <li>RIP:거리벡터기반 라우팅 프로토콜<br>
                    거리는 패킷이 경유한 라우터의 수,<br> 
                    즉 홉의 수,특정 수신지까지 도달하기<br>
                    위해 홉 수가 가장 적은 경로를<br> 
                    최적의 경로라고 판단,홉 수가<br> 
                    적을수록 라우팅 테이블상의<br> 
                    메트릭 값도 작아짐, 주기적으로<br> 
                    인접 라우터끼리 경로 정보 교환<br> 
                    라우팅 테이블 갱신,특정<br> 
                    수신지까지의 홉수 계산</li>
                <li>OSPF:최적의 경로를 선정하는<br> 
                    과정에서 링크 상태를 사용,<br>
                    대역폭을 기반으로 메트릭을 계산하여<br>
                    최적의 경로를 결정, 대역폭이<br> 
                    높은 링크일수록 메트릭이<br> 
                    낮은 경로로 인식</li>
                <li>EGP:BGP(BorderGatewayProtocol)<br>
                    AS간의 통신에서 사용되는 대표적인<br> 
                    프로토콜 엄밀하게는 AS간의 통신이<br>
                    가능한 프로토콜,BGP로 AS내 라우터<br>
                    간 통신도 가능</li>
                <li>eBGP BGP-AS간의 통신을 위한 BGP</li>
                <li>iBGP BGP-AS내의 통신을 위한 BGP</li>
                <li>피어링:다른 AS와의 BGP연결을<br> 
                    유지하기 위해서 BGP 라우터끼리<br> 
                    피어가 되도록 연결되는 과정</li>
                <li>BGP는 RIP과OSPF에 비해 최적의<br> 
                    경로를 결정하는 과정이 복잡하고<br>
                    일정하지 않은 경우가 많음<br>
                    경로 결정 과정에서 수신지 주소와<br> 
                    더불어 다양한 속성과 정책이<br> 
                    고려되기 때문</li>
                <li>BGP의 속성은 경로에 대한 부가 정보</li>
                <li>AS-PATH:메시지가 수신지에 이르는<br>
                    과정에서 통과하는 AS들의 목록<br>
                    메시지가 AS를 거칠 때마다<br> 
                    AS-PATH에는 거쳐 간 AS가 추가</li>
                <li>NEXT-HOP:홉,다음으로 거칠<br> 
                    라우터의 IP주소</li>
                <li>LOCAL-PREF:지역 선호도<br>
                    AS외부 경로 선택에 있어 AS내부에서<br>
                    어떤 경로를 선호할지에 대한 척도<br>
                    일반적으로 AS-PATH나 NEXT-HOP<br>
                    속성보다 우선시,AS과리 주체가<br> 
                    설정하는 정책의 영향을 받음</li>
                <li>정책:AS관리 주체에 따라 각기<br> 
                    다른 상이한 정책 사용가능</li>
                <li>특정AS우대 정책</li>
                <li>특정AS차단 정책</li>
                <li>보안/안정성 우선 정책</li>
                <li>성능 우선 정책</li>
            <h4>전송 계층 개요</h4>    
                <li>네트워크 계층과 응용 계층<br> 
                    사이의 전송 계층</li>
                <li>IP한계보완:신뢰 할 수 있는<br> 
                    통신과 연결형 통신 기능 제공</li>
                <li>응용 계층의 프로세스 식별:<br>
                    포트 번호 활용</li>
            <h4>IP 한계를 보완하는 전송 계층</h4>     
                <li>신뢰할 수 없는 통신과 비연결형 통신</li>
                <li>IP의 특징</li>
                <li>신뢰할 수 없는 프로토콜</li>
                <li>비연결형 프로토콜</li>
                <li>IP패킷의 전달=신뢰성이<br>
                    없는 통신+비연결형</li>
                <li>신뢰할수 없는 통신:패킷이<br> 
                    수신지까지 제대로 전송되었다는<br> 
                    보장을 하지 않음,통신 관정에서<br> 
                    패킷이 잘 못 전송되어도 이를<br> 
                    확인하지 않고,재전송도 하지 않으며<br> 
                    순서대로 패킷이 도착할 것이라는<br> 
                    보장도 하지 않는다는 의미</li>
                <li>비연결형 통신:송수신 호스트 간에<br> 
                    사전 연결 수립 작업을 거치지 않음,<br>
                    그저 수신지를 향해 패킷을<br> 
                    보내기만 할뿐</li>
                <li>IP는 왜 신뢰할 수 없는<br> 
                    비연결형 통신을 할까:주된 이유는<br>
                    성능! 신뢰할 수 있는 연결형 통신=<br>
                    성능에 악영향,신뢰성 있는 전송이<br> 
                    모든 경우에 필요한 것은 아님</li>
            <h4>TCP와UDP</h4>    
                <li>TCP:연결형 통신을 가능하게 함-<br>
                    송수신하는 동안에는 연결을 유지하고,<br>
                    송수신이 끝나면 연결을 종료,신뢰성이<br>
                    있는 통신을 가능하게함,재전송을 통한<br> 
                    오류제어,흐름제어,혼잡제어등<br> 
                    다양한 기능들을 제공</li>
                <li>UDP:신뢰할 수 없는 통신, 비연결형<br> 
                    통신을 가능하게함,TCP보다는 비교적<br> 
                    빠른 전송이 가능</li>
            <h4>포트를 활용한 애플리케이션 식별</h4>    
                <li>포트(port):네트워크 상의<br> 
                    애플리케이션 식별 정보</li>
                <li>포트의 분류:패킷 내 수신지 포트와<br> 
                    송신지 포트를 통해 송수신지 호스트<br>
                    의 애플리케이션을 식별,16비트로<br> 
                    표현 가능-사용가능한 포트의 수는<br>
                    2의16승(65536)개,<br>
                    할당 가능한 포트번호:0~25535번</li>
                <li>잘 알려진 포트(well-known port)<br>
                    0~1023,시스템포트,범용적으로<br> 
                    사용되는 애플리케이션 프로토콜이<br> 
                    일반적으로 사용하는 포트 번호를 의미<br></li>
                    <li>FTP:20,21</li>
                    <li>SSH:22</li>
                    <li>TELNET:23</li>
                    <li>DNS:53</li>
                    <li>DHCP:67,68</li>
                    <li>HTTP:80</li>
                    <li>HTTPS:443</li>
                <li>등록된 포트(registered port)<br>
                    1024~49515,잘 알려진 포트에<br> 
                    비해 덜 범용적,흔히 사용되는<br> 
                    애플리케이션 프로토콜에<br> 
                    할당하기 위해 사용<br>
                    </li>
                    <li>HTTP의 대체:8080</li>
                    <li>MySQL:3306</li>
                <li>동적 포트(dynamic port)</li>
                <li>사설포트,임시포트</li>
                <li>특별히 관리되지 않는 포트 번호<br> 
                    범위:자유롭게 사용 가능,서버는<br> 
                    대부분 잘 알려진 포트와 등록된<br> 
                    포트 사용,클라이언트는 대부분<br> 
                    동적 포트 사용,예-웹브라우저</li>
            <h4>특정 호스트에서 실행 중인 특정<br> 
                애플리케이션 프로세스 식별</h4>
                <li>IP주소:포트번호 형식</li>
                <li>192.168.0.15:8000</li>
                <li>IP주소-호스트식별:<br>
                    포트번호-애플리케이션 프로세스 식별</li>
                <li>포트번호 관찰하고 해석하기</li>
                <li>윈도우-리소스모니터</li>
            <h4>포트를 활용하기는 기술<br>
                포트 기반 NAT</h4>    
                <li>NAT변환 테이블:<br>
                    변환의 대상이 되는 IP 주소 쌍</li>
                <li>사설IP주소 하나당 공인IP주소<br>
                    하나가 대응:많은 사설IP주소를<br> 
                    변환하기에는 무리가 있음<br>
                    공인IP 주소의 낭비:사설IP주소의<br> 
                    수만큼 공인 IP주소가 필요</li>
                <li>포트기반의NAT를 NAPT라고함<br>
                    (Network Address Port Translation)<br>
                    (Address Port Translation)<br>
                    NAPT는 NAT테이블에 변환할 IP주소<br> 
                    쌍과 더블어 포트번호도 함께 기록하고<br>
                    변환,하나의 공인IP주소를<br> 
                    여러 사설IP주소가공유가능<br>
                    사설IP주소:공인IP주소를n:1로 변환<br>
                    공인IP주소 수 부족 문제를 개선한 기술<br>
                    아이피주소가 같더라도<br> 
                    포트번호가 다르기때문</li>
            <h4>포트 포워딩</h4>    
                <li>특정IP주소와 포트번호 쌍을<br> 
                    호스트에게 할당한뒤 외부 호스트에게<br>
                    해당 접속 정보(IP주소:포트번호쌍)<br>
                    을 알려주면</li>
            <h4>ICMP:IP의 전송 특성을 보완한다</h4>    
                <li>IP패킷의 전송 과정에 대한<br> 
                    피드백 메시지 제공</li>
                <li>피드백 메시지:전송과정에서 발생한<br> 
                    문제 상황에 대한 오류 보고<br>
                    네트워크에 대한 진단 정보<br>
                    (네트워크상의 정보 제공)</li>
                <li>ICMP메시지=타입+코드</li>
                <li>타입:ICMP메시지 유형번호</li>
                <li>코드:구체적인 메시지 내용 번호</li>
                <li>CMD traceroute www.google.com</li>
                <li>ICMP는 IP의 보조일뿐,<br>
                    신뢰성의 완전 보장은 하지 않는다</li>
            <h4>TCP와UDP자세히 알아보기</h4>    
                <li>TCP(Transmission Control Protocol)<br>
                    신뢰할 수 있는 통신을 위한 연결형</li>
                <li>UDP(User Datagram protocol)<br>
                    TCP보다 신뢰성은 떨어지지만 비교적<br> 
                    빠른 통신이 가능한 비연결형 프로토콜</li>
                <li>TCP통신 단계<br>
                    TCP는 통신(데이터 송수신)하기 전에<br> 
                    연결을 수립하고 통신이 끝나면<br>
                    연결을 종료</li>
                <li>1.연결수립</li>
                <li>2.데이터 송수신:재전송을 통한<br>
                    오류제어,흐름제어,혼잡제어</li>
                <li>3.연결종료</li>
            <h4>MSS(Maximum Segment Size)</h4>    
                <li>TCP로 전송할 수 있는<br>
                    최대 페이로드 크기</li>
                <li>TCP헤더 크기는 제외</li>
                <li>(MTU는 헤더도 포함)</li>
            <h4>TCP 세그먼트 구조</h4>    
                <li>송신지,수신지 포트:<br>
                    송수신하는 포트 번호</li>
                <li>순서번호:순서번호가 명시되는 필드<br>
                    송수신되는 세그먼트 데이터의<br>
                    첫 바이트에 부여되는 번호<br>
                    세그먼트의 올바른 송수신<br> 
                    순서를 보장하기 위한 번호</li>
                <li>확인 응답 번호:상대 호스트가 보낸<br> 
                    세그먼트에 대한 응답 다음으로 수신<br>
                    하기를 기대하는 순서 번호가 명시</li>
            <h4>응용계층으로부터 1900바이트의<br>
                데이터를 전달받았다고 가정</h4>    
                <li>MSS단위로 전송<br>
                    (편의상 MSS가 500바이트라고가정)</li>
                <li>4개의 세그먼트로 분할</li>
                <li>A500.B500.C500.D400</li>
                <li>순서번호=<br>
                    초기 순서 번호+송신한 바이트수</li>
                <li>첫번째 세그먼트A에는 초기순서번호<br>
                    (무작위값)100 </li>
                <li>세그먼트B의 순서 번호는<br> 
                    초기 순서 번호인 100에서<br> 
                    500바이트 떨어진 셈이므로 600</li>
                <li>세그먼트C는 1100</li>
                <li>세그먼트D는 1600</li>
                <li>확인 응답 번호:수신자가 다음으로<br> 
                    받기를 기대하는 순서번호<br>
                    (일반적으로 수신한 순서번호+1)<br>
                    확인 응답 번호 값을 보내기<br> 
                    위해서는 제어 비트에서 승이을<br>
                    나타내는 비트인 ACK플래그를<br>
                    1로 설정</li>
                <li>제어비트,플래그비트:현재<br> 
                    세그먼트에 대한 부가정보,<br>
                    기본적으로 8비트로 구성<br>
                    ACK:<br>
                    세그먼트의 승인을 나타내기 위한 비트
                    SYN:연결을 수립하기 위한 비트<br>
                    FIN:연결을 종료하기 위한 비트</li>
                <li>윈도우:수신 윈도우<br>
                    (한번에 수신하고자하는 데이터의 양)<br>
                    의 크기가 명시</li>
            <h4>TCP연결 수립과 종료</h4>    
                <li>연결수립:쓰리 웨이 핸드셰이크</li>
                <li>쓰리웨이 핸드 셰이크:세 개의 단계로<br>
                    이루어진 TCP의 연결 수립 과정<br>
                    호스트A와B가 쓰리웨이 핸드셰이크를<br>
                    한다고 가정</li>
                <li>A->B<br>
                    SYN세그먼트를 보냄<br>
                    호스트A의초기순서번호,<br>
                    1로설정된SYN비트<br>
                    연결시작합니다란 뜻</li>
                <li>B->A<br>
                    SYN+ACK세그먼트 보냄<br>
                    호스트B의 초기순서번호<br>
                    호스트A가 전송한 세그먼트에<br>
                    대한 확인 응답 번호<br>
                    1로 설정된SYN비트<br>
                    1로 설정된ACK비트<br>
                    네 확인 했습니다 연결시작하세요</li>
                <li>A->B<br>
                    ACK세그먼트 보냄<br>
                    호스트A의 다음 순서 번호<br>
                    호스트B가 전송한 세그먼트에<br>
                    대한 확인 응답 번호<br>
                    1로 설정된 ACK비트<br>
                    네 확입했습니다</li>
                <li>액티브 오픈:<br>
                    연결 시작 호스트의 연결 수립 과정</li>
                <li>패시브 오픈:<br>
                    연결 수락 호스트의 연결 수립 과정</li>
                <li>연결 종료:<br>
                    송수신 호스트가 각각 한 번씩<br> 
                    FIN과 ACK를 주고 받으며<br> 
                    TCP가 연결 종료<br>
                    액티브 클로즈:<br>
                    종료 시작 호스트의 연결 과정<br>
                    패시브 클로즈:<br>
                    종료 수락 호스트의 종료 과정</li>
                <li>A->B<br>
                    FIN세그먼트 보냄<br>
                    1로 설정된 FIN비트<br>
                    연결 끊을 게요</li>
                <li>B->A<br>
                    ACK세그먼트 보냄<br>
                    호스트가 A가 전송한 세그먼트에<br> 
                    대한 확인 응답 번호<br>
                    1로 설정된ACK비트<br>
                    네 확인 했습니다</li>
                <li>B->A<br>
                    잠시후FIN세그먼트 보냄<br>
                    1로 설정된 FIN비트<br>
                    이제 연결 끊어요</li>
                <li>A->B<br>
                    ACK세그먼트 보냄<br>
                    호스트B가 전송한 세그먼트에<br>
                    대한 확인 응답 번호<br>
                    1로 설정된 ACK비트<br>
                    네 확인 했습니다</li>
                <li>네 단계로 연결을 종료한다는 점에서<br>
                    포 웨이 핸드세이크라고 부르기도함</li>
            <h4>TCP상태</h4>    
                <li>상태:현재 어던 통신 과정에<br> 
                    있는지를 나타내는 정보</li>
                <li>상태를 유지하고 활용하는 TCP<br>
                    스테이트풀 프로토콜이라고 함</li>
                <li>TCP상태의 유형<br>
                    연결이 수립되지 않은 상태<br>
                    CLOSED:아무런 연결이 없는 상태<br>
                    LISTEN:일종의 연결 대기 상태<br>
                    (SYN세그먼트를 기다리는 상태)<br>
                    서버로서 동작하는 패시브 오픈<br> 
                    호스트는 일반적으로 LISTEN상태 유지</li>
                <li>연결수립 과정에서 주로 볼수있는 상태<br>
                    SYN-SENT:<br>
                    연결 요청을 보낸뒤 대기하는 상태<br>
                    액티브 오픈 호스트가SYN세그먼트를<br> 
                    보낸 뒤 그에 대한 응답인 SYN+ACK<br>
                    세그먼트를 기다리는 상태<br>
                    SYN-RECEIVED:<br>
                    패시브 오픈 호스트가 SYN + ACK<br>
                    세그먼트를 보낸 뒤 그에 대한<br>
                    ACK세그먼트를 기다리는 상태
                    ESTABLISHED:<br>
                    연결이 확립되었음을 나타내는 상태</li>
                <li>연결종료 과정에서 주로 볼수있는 상태<br>
                    FIN-WAIT-1:<br>
                    일반적인 TCP연결 종료 과정에 있어<br>
                    FIN-WAIT-1은 연결 종료의 첫 단계<br>
                    CLOSED-WAIT:<br>
                    종료 요청인FIN세그먼트를 받은 <br>
                    패시브 클로즈 호스트가 그에대한<br> 
                    응답으로 ACK세그먼트를 보낸<br> 
                    후 대기하는 상태</li>
                <li>FIN-WAIT-2:<br>
                    FIN-WAIT-1상태에서ACK세그먼트를<br> 
                    받고 상대 호스트의 FIN세그먼트를<br> 
                    기다리는 상태<br>
                    LAST-ACK:<br>
                    CLOSED-WAIT상태에서<br>
                    FIN세그먼트를 전송한 뒤 이에<br>
                    대한 ACK세그먼트를<br> 
                    기다리는 상태</li>
                <li>TIME-WAIT:<br>
                    액티브 클로즈 호스트가 FIN세그먼트를<br>
                    수신한 뒤, 이에 대한 ACK세그먼트를<br>
                    전송한 뒤 접어드는 상태<br>
                    패시브 클로즈 호스트는 마지막<br> 
                    ACK세그먼트를 수신하면<br> 
                    CLOSED 상태로 전이<br>
                    TIME-WAIT상태의 액티브 클로즈<br> 
                    호스트는 일정 시간을 기다린 뒤<br> 
                    CLOSED상태로 전이</li>
                <li>간단한 명령어로 TCP의 상태 확인<br>
                    맥OS,리눅스 netstat</li>
            <h4>UDP</h4>    
                <li>UDP데이터그램의 구조<br>
                    UDP는TCP와는 달리 비연결형 통신을<br> 
                    수행하는 신뢰할 수 없는 프로토콜<br>
                    그래서 연결이 수립 및 해제,<br>
                    재전송을 통한 오류제어,혼잡 제어,<br>
                    흐름 제어등을 수행하지 않음<br>
                    상태를 유지 하지도 않음-<br>
                    스테이트리스 프로토콜이라함<br>
                    UDP는TCP에 비해 적은 오버헤드로<br> 
                    패킷을 빠르게 처리<br>
                    주로 실시간 스트리밍 서비스,인터넷<br> 
                    전화처럼 실시간성이 강조되는<br> 
                    상황에서 TCP보다 많이 쓰임</li>
            <h4><a href="page_network7.html"> NW part7 </a></h4>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>