<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network part6</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
                        <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_javascript2.html"> JavaScript-with Web </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network-OSI model </a></li>
            <li><a href="page_network2.html"> Physical-Data-layer1 </a></li>
            <li><a href="page_network3.html"> Physical-Data-layer2 </a></li>
            <li><a href="page_network4.html"> Network-layer1 </a></li>
            <li><a href="page_network5.html"> Network-layer2 </a></li>
            <li><a href="page_network6.html"> Transport-layer </a></li>
            <li><a href="page_network7.html"> Application-layer1 </a></li>
            <li><a href="page_network8.html"> Application-layer2 </a></li>
            <li><a href="page_network9.html"> Application-layer3 </a></li>
            <li><a href="page_network10.html"> Application-layer4 </a></li>
            <li><a href="page_network11.html"> Application-layer5 </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>Transport-layer</h2>
            <ul>
            <h4>전송 계층 개요</h4>    
                <li>네트워크 계층과 응용 계층<br> 
                    사이의 전송 계층</li>
                <li>IP한계보완:신뢰 할 수 있는<br> 
                    통신과 연결형 통신 기능 제공</li>
                <li>응용 계층의 프로세스 식별:<br>
                    포트 번호 활용</li>
            <h4>IP 한계를 보완하는 전송 계층</h4>     
                <li>신뢰할 수 없는 통신과 비연결형 통신</li>
                <li>IP의 특징</li>
                <li>신뢰할 수 없는 프로토콜</li>
                <li>비연결형 프로토콜</li>
                <li>IP패킷의 전달=신뢰성이<br>
                    없는 통신+비연결형</li>
                <li>신뢰할수 없는 통신:패킷이<br> 
                    수신지까지 제대로 전송되었다는<br> 
                    보장을 하지 않음,통신 관정에서<br> 
                    패킷이 잘 못 전송되어도 이를<br> 
                    확인하지 않고,재전송도 하지 않으며<br> 
                    순서대로 패킷이 도착할 것이라는<br> 
                    보장도 하지 않는다는 의미</li>
                <li>비연결형 통신:송수신 호스트 간에<br> 
                    사전 연결 수립 작업을 거치지 않음,<br>
                    그저 수신지를 향해 패킷을<br> 
                    보내기만 할뿐</li>
                <li>IP는 왜 신뢰할 수 없는<br> 
                    비연결형 통신을 할까:주된 이유는<br>
                    성능! 신뢰할 수 있는 연결형 통신=<br>
                    성능에 악영향,신뢰성 있는 전송이<br> 
                    모든 경우에 필요한 것은 아님</li>
            <h4>TCP와UDP</h4>    
                <li>TCP:연결형 통신을 가능하게 함-<br>
                    송수신하는 동안에는 연결을 유지하고,<br>
                    송수신이 끝나면 연결을 종료,신뢰성이<br>
                    있는 통신을 가능하게함,재전송을 통한<br> 
                    오류제어,흐름제어,혼잡제어등<br> 
                    다양한 기능들을 제공</li>
                <li>UDP:신뢰할 수 없는 통신, 비연결형<br> 
                    통신을 가능하게함,TCP보다는 비교적<br> 
                    빠른 전송이 가능</li>
            <h4>포트를 활용한 애플리케이션 식별</h4>    
                <li>포트(port):네트워크 상의<br> 
                    애플리케이션 식별 정보</li>
                <li>포트의 분류:패킷 내 수신지 포트와<br> 
                    송신지 포트를 통해 송수신지 호스트<br>
                    의 애플리케이션을 식별,16비트로<br> 
                    표현 가능-사용가능한 포트의 수는<br>
                    2의16승(65536)개,<br>
                    할당 가능한 포트번호:0~25535번</li>
                <li>잘 알려진 포트(well-known port)<br>
                    0~1023,시스템포트,범용적으로<br> 
                    사용되는 애플리케이션 프로토콜이<br> 
                    일반적으로 사용하는 포트 번호를 의미<br></li>
                    <li>FTP:20,21</li>
                    <li>SSH:22</li>
                    <li>TELNET:23</li>
                    <li>DNS:53</li>
                    <li>DHCP:67,68</li>
                    <li>HTTP:80</li>
                    <li>HTTPS:443</li>
                <li>등록된 포트(registered port)<br>
                    1024~49515,잘 알려진 포트에<br> 
                    비해 덜 범용적,흔히 사용되는<br> 
                    애플리케이션 프로토콜에<br> 
                    할당하기 위해 사용<br>
                    </li>
                    <li>HTTP의 대체:8080</li>
                    <li>MySQL:3306</li>
                <li>동적 포트(dynamic port)</li>
                <li>사설포트,임시포트</li>
                <li>특별히 관리되지 않는 포트 번호<br> 
                    범위:자유롭게 사용 가능,서버는<br> 
                    대부분 잘 알려진 포트와 등록된<br> 
                    포트 사용,클라이언트는 대부분<br> 
                    동적 포트 사용,예-웹브라우저</li>
            <h4>특정 호스트에서 실행 중인 특정<br> 
                애플리케이션 프로세스 식별</h4>
                <li>IP주소:포트번호 형식</li>
                <li>192.168.0.15:8000</li>
                <li>IP주소-호스트식별:<br>
                    포트번호-애플리케이션 프로세스 식별</li>
                <li>포트번호 관찰하고 해석하기</li>
                <li>윈도우-리소스모니터</li>
            <h4>포트를 활용하기는 기술<br>
                포트 기반 NAT</h4>    
                <li>NAT변환 테이블:<br>
                    변환의 대상이 되는 IP 주소 쌍</li>
                <li>사설IP주소 하나당 공인IP주소<br>
                    하나가 대응:많은 사설IP주소를<br> 
                    변환하기에는 무리가 있음<br>
                    공인IP 주소의 낭비:사설IP주소의<br> 
                    수만큼 공인 IP주소가 필요</li>
                <li>포트기반의NAT를 NAPT라고함<br>
                    (Network Address Port Translation)<br>
                    (Address Port Translation)<br>
                    NAPT는 NAT테이블에 변환할 IP주소<br> 
                    쌍과 더블어 포트번호도 함께 기록하고<br>
                    변환,하나의 공인IP주소를<br> 
                    여러 사설IP주소가공유가능<br>
                    사설IP주소:공인IP주소를n:1로 변환<br>
                    공인IP주소 수 부족 문제를 개선한 기술<br>
                    아이피주소가 같더라도<br> 
                    포트번호가 다르기때문</li>
            <h4>포트 포워딩</h4>    
                <li>특정IP주소와 포트번호 쌍을<br> 
                    호스트에게 할당한뒤 외부 호스트에게<br>
                    해당 접속 정보(IP주소:포트번호쌍)<br>
                    을 알려주면</li>
            <h4>ICMP:IP의 전송 특성을 보완한다</h4>    
                <li>IP패킷의 전송 과정에 대한<br> 
                    피드백 메시지 제공</li>
                <li>피드백 메시지:전송과정에서 발생한<br> 
                    문제 상황에 대한 오류 보고<br>
                    네트워크에 대한 진단 정보<br>
                    (네트워크상의 정보 제공)</li>
                <li>ICMP메시지=타입+코드</li>
                <li>타입:ICMP메시지 유형번호</li>
                <li>코드:구체적인 메시지 내용 번호</li>
                <li>CMD traceroute www.google.com</li>
                <li>ICMP는 IP의 보조일뿐,<br>
                    신뢰성의 완전 보장은 하지 않는다</li>
            <h4>TCP와UDP자세히 알아보기</h4>    
                <li>TCP(Transmission Control Protocol)<br>
                    신뢰할 수 있는 통신을 위한 연결형</li>
                <li>UDP(User Datagram protocol)<br>
                    TCP보다 신뢰성은 떨어지지만 비교적<br> 
                    빠른 통신이 가능한 비연결형 프로토콜</li>
                <li>TCP통신 단계<br>
                    TCP는 통신(데이터 송수신)하기 전에<br> 
                    연결을 수립하고 통신이 끝나면<br>
                    연결을 종료</li>
                <li>1.연결수립</li>
                <li>2.데이터 송수신:재전송을 통한<br>
                    오류제어,흐름제어,혼잡제어</li>
                <li>3.연결종료</li>
            <h4>MSS(Maximum Segment Size)</h4>    
                <li>TCP로 전송할 수 있는<br>
                    최대 페이로드 크기</li>
                <li>TCP헤더 크기는 제외</li>
                <li>(MTU는 헤더도 포함)</li>
            <h4>TCP 세그먼트 구조</h4>    
                <li>송신지,수신지 포트:<br>
                    송수신하는 포트 번호</li>
                <li>순서번호:순서번호가 명시되는 필드<br>
                    송수신되는 세그먼트 데이터의<br>
                    첫 바이트에 부여되는 번호<br>
                    세그먼트의 올바른 송수신<br> 
                    순서를 보장하기 위한 번호</li>
                <li>확인 응답 번호:상대 호스트가 보낸<br> 
                    세그먼트에 대한 응답 다음으로 수신<br>
                    하기를 기대하는 순서 번호가 명시</li>
            <h4>응용계층으로부터 1900바이트의<br>
                데이터를 전달받았다고 가정</h4>    
                <li>MSS단위로 전송<br>
                    (편의상 MSS가 500바이트라고가정)</li>
                <li>4개의 세그먼트로 분할</li>
                <li>A500.B500.C500.D400</li>
                <li>순서번호=<br>
                    초기 순서 번호+송신한 바이트수</li>
                <li>첫번째 세그먼트A에는 초기순서번호<br>
                    (무작위값)100 </li>
                <li>세그먼트B의 순서 번호는<br> 
                    초기 순서 번호인 100에서<br> 
                    500바이트 떨어진 셈이므로 600</li>
                <li>세그먼트C는 1100</li>
                <li>세그먼트D는 1600</li>
                <li>확인 응답 번호:수신자가 다음으로<br> 
                    받기를 기대하는 순서번호<br>
                    (일반적으로 수신한 순서번호+1)<br>
                    확인 응답 번호 값을 보내기<br> 
                    위해서는 제어 비트에서 승이을<br>
                    나타내는 비트인 ACK플래그를<br>
                    1로 설정</li>
                <li>제어비트,플래그비트:현재<br> 
                    세그먼트에 대한 부가정보,<br>
                    기본적으로 8비트로 구성<br>
                    ACK:<br>
                    세그먼트의 승인을 나타내기 위한 비트
                    SYN:연결을 수립하기 위한 비트<br>
                    FIN:연결을 종료하기 위한 비트</li>
                <li>윈도우:수신 윈도우<br>
                    (한번에 수신하고자하는 데이터의 양)<br>
                    의 크기가 명시</li>
            <h4>TCP연결 수립과 종료</h4>    
                <li>연결수립:쓰리 웨이 핸드셰이크</li>
                <li>쓰리웨이 핸드 셰이크:세 개의 단계로<br>
                    이루어진 TCP의 연결 수립 과정<br>
                    호스트A와B가 쓰리웨이 핸드셰이크를<br>
                    한다고 가정</li>
                <li>A->B<br>
                    SYN세그먼트를 보냄<br>
                    호스트A의초기순서번호,<br>
                    1로설정된SYN비트<br>
                    연결시작합니다란 뜻</li>
                <li>B->A<br>
                    SYN+ACK세그먼트 보냄<br>
                    호스트B의 초기순서번호<br>
                    호스트A가 전송한 세그먼트에<br>
                    대한 확인 응답 번호<br>
                    1로 설정된SYN비트<br>
                    1로 설정된ACK비트<br>
                    네 확인 했습니다 연결시작하세요</li>
                <li>A->B<br>
                    ACK세그먼트 보냄<br>
                    호스트A의 다음 순서 번호<br>
                    호스트B가 전송한 세그먼트에<br>
                    대한 확인 응답 번호<br>
                    1로 설정된 ACK비트<br>
                    네 확입했습니다</li>
                <li>액티브 오픈:<br>
                    연결 시작 호스트의 연결 수립 과정</li>
                <li>패시브 오픈:<br>
                    연결 수락 호스트의 연결 수립 과정</li>
                <li>연결 종료:<br>
                    송수신 호스트가 각각 한 번씩<br> 
                    FIN과 ACK를 주고 받으며<br> 
                    TCP가 연결 종료<br>
                    액티브 클로즈:<br>
                    종료 시작 호스트의 연결 과정<br>
                    패시브 클로즈:<br>
                    종료 수락 호스트의 종료 과정</li>
                <li>A->B<br>
                    FIN세그먼트 보냄<br>
                    1로 설정된 FIN비트<br>
                    연결 끊을 게요</li>
                <li>B->A<br>
                    ACK세그먼트 보냄<br>
                    호스트가 A가 전송한 세그먼트에<br> 
                    대한 확인 응답 번호<br>
                    1로 설정된ACK비트<br>
                    네 확인 했습니다</li>
                <li>B->A<br>
                    잠시후FIN세그먼트 보냄<br>
                    1로 설정된 FIN비트<br>
                    이제 연결 끊어요</li>
                <li>A->B<br>
                    ACK세그먼트 보냄<br>
                    호스트B가 전송한 세그먼트에<br>
                    대한 확인 응답 번호<br>
                    1로 설정된 ACK비트<br>
                    네 확인 했습니다</li>
                <li>네 단계로 연결을 종료한다는 점에서<br>
                    포 웨이 핸드세이크라고 부르기도함</li>
            <h4>TCP상태</h4>    
                <li>상태:현재 어던 통신 과정에<br> 
                    있는지를 나타내는 정보</li>
                <li>상태를 유지하고 활용하는 TCP<br>
                    스테이트풀 프로토콜이라고 함</li>
                <li>TCP상태의 유형<br>
                    연결이 수립되지 않은 상태<br>
                    CLOSED:아무런 연결이 없는 상태<br>
                    LISTEN:일종의 연결 대기 상태<br>
                    (SYN세그먼트를 기다리는 상태)<br>
                    서버로서 동작하는 패시브 오픈<br> 
                    호스트는 일반적으로 LISTEN<br>
                    상태 유지</li>
                <li>연결수립 과정에서 주로 볼수있는 상태<br>
                    SYN-SENT:<br>
                    연결 요청을 보낸뒤 대기하는 상태<br>
                    액티브 오픈 호스트가SYN세그먼트를<br> 
                    보낸 뒤 그에 대한 응답인 SYN+ACK<br>
                    세그먼트를 기다리는 상태<br>
                    SYN-RECEIVED:<br>
                    패시브 오픈 호스트가 SYN + ACK<br>
                    세그먼트를 보낸 뒤 그에 대한<br>
                    ACK세그먼트를 기다리는 상태
                    ESTABLISHED:<br>
                    연결이 확립되었음을 나타내는 상태</li>
                <li>연결종료 과정에서 주로 볼수있는 상태<br>
                    FIN-WAIT-1:<br>
                    일반적인 TCP연결 종료 과정에 있어<br>
                    FIN-WAIT-1은 연결 종료의 첫 단계<br>
                    CLOSED-WAIT:<br>
                    종료 요청인FIN세그먼트를 받은 <br>
                    패시브 클로즈 호스트가 그에대한<br> 
                    응답으로 ACK세그먼트를 보낸<br> 
                    후 대기하는 상태</li>
                <li>FIN-WAIT-2:<br>
                    FIN-WAIT-1상태에서ACK세그먼트를<br> 
                    받고 상대 호스트의 FIN세그먼트를<br> 
                    기다리는 상태<br>
                    LAST-ACK:<br>
                    CLOSED-WAIT상태에서<br>
                    FIN세그먼트를 전송한 뒤 이에<br>
                    대한 ACK세그먼트를<br> 
                    기다리는 상태</li>
                <li>TIME-WAIT:<br>
                    액티브 클로즈 호스트가<br> 
                    FIN세그먼트를<br>
                    수신한 뒤, 이에 대한 ACK세그먼트를<br>
                    전송한 뒤 접어드는 상태<br>
                    패시브 클로즈 호스트는 마지막<br> 
                    ACK세그먼트를 수신하면<br> 
                    CLOSED 상태로 전이<br>
                    TIME-WAIT상태의 액티브 클로즈<br> 
                    호스트는 일정 시간을 기다린 뒤<br> 
                    CLOSED상태로 전이</li>
                <li>간단한 명령어로 TCP의 상태 확인<br>
                    맥OS,리눅스 netstat</li>
            <h4>UDP</h4>    
                <li>UDP데이터그램의 구조<br>
                    UDP는TCP와는 달리 비연결형 통신을<br> 
                    수행하는 신뢰할 수 없는 프로토콜<br>
                    그래서 연결이 수립 및 해제,<br>
                    재전송을 통한 오류제어,혼잡 제어,<br>
                    흐름 제어등을 수행하지 않음<br>
                    상태를 유지 하지도 않음-<br>
                    스테이트리스 프로토콜이라함<br>
                    UDP는TCP에 비해 적은 오버헤드로<br> 
                    패킷을 빠르게 처리<br>
                    주로 실시간 스트리밍 서비스,인터넷<br> 
                    전화처럼 실시간성이 강조되는<br> 
                    상황에서 TCP보다 많이 쓰임</li>
            <h4>TCP의 오류:흐름,혼잡제어</h4>    
                <li>TCP의 기능:재전송을 기반으로<br> 
                    다양한 오류를 제어,흐름 제어를<br> 
                    통해 처리할 수 있을 만큼의<br> 
                    데이터 송수신,혼잡 제어를 통해<br> 
                    네트워크가 혼잡한 정도에<br> 
                    따라 전송량 조절</li>
            <h4>재전송 기반의 오류 제어</h4>    
                <li>오류 검출과 재전송</li>    
                <li>TCP세그먼트의 체크섬 필드,충분할까?</li>
                <li>TCP가 신뢰성을 제대로 보장하려면?</li>
                <li>송신 호스트가 송신한 세그먼트에<br> 
                    문제가 발생했음을 인지할수 있어야</li>
                <li>오류를 감지하게 되면 해당<br>
                    세그먼트를 재전송할 수 있어야</li>
                <li>그렇다면 TCP는 언제 오류를<br> 
                    검출하고 재전송할까?</li>
                <li>중복된ACK세그먼트를 수신했을때</li>
                <li>타임아웃이 발생했을때</li>
                <li>호스트가 세그먼트를 전송할<br> 
                    때마다 재전송 타이머 시작</li>
                <li>타임아웃이 발생할 때까지<br> 
                    ACK세그먼트를 받지 못하면 재전송</li>
                <li>재전송 기법:<br>
                    ARQ(Automatic Repeat Request)</li>
                <li>수신 호스트의 답변(ACK)과 타임<br>
                    아웃을 토대로 문제를 진단하고,<br>
                    문제가 생긴 메시지를 재전송함으로써<br>
                    신뢰성을 확보하는 방식</li>
                <li>ARQ의 대표적인 3가지 방식</li>
                <li>Stop-and-Wait ARQ<br>
                    제대로 전달했음을 확인하기<br> 
                    전까지는 새로운 메시지를 보내지<br> 
                    않는 방식,송신하고,확인받고,<br>
                    송신하고,확인받고 반복<br>
                    장점:단순하지만,높은 신뢰성을 보장<br>
                    단점:네트워크의 이용효율이<br> 
                    낮아지고 성능이 저하됨<br>
                    송신호스트A:확인응답을 받기 전에는<br>
                    더 보내고 싶어도 못 보냄<br>
                    수신호스트B:더 많은 데이터를 처리할<br> 
                    수 있어도 하나씩만 확인 응답<br>
                    이러한 문제점 해결방법<br>
                    각 세그먼트에 대한 ACK세그먼트가<br> 
                    도착하기 전이더라도 여러 세그먼트를<br> 
                    보낼 수 있어야함<br>
                    파이프라이닝(pipelining):<br>
                    연속해서 메시지를 전송할 수 있는 기술</li>
                <li>Go-Back-N ARQ<br>
                    파이프라이닝 기반ARQ일종<br>
                    여러 세그먼트 전송 중 오류가 발생하면<br>
                    해당 세그먼트부터 전부 재전송<br>
                    순서 번호 n번에 대한 ACK세그먼트는<br> 
                    n번만의 확인 응답이 아닌n번 까지의<br> 
                    누적 확인 응답(CACK,<br>
                    Cumulative Acknowledgment)<br>
                    참고:빠른 재전송(fast retransmit)<br>
                    재전송 타이머가 만료되기 전이라도<br> 
                    세 번의 동일한 ACK세그먼트를<br> 
                    받았다면 곧바로 재전송<br>
                    타이머가 끝날 때까지 기다리는<br>
                    시간을 줄일 수 있음</li>
                <li>Selective Repeat ARQ<br>
                    선택적으로 재전송:각각의 패킷들에<br> 
                    대해 ACK세그먼트를 보내는 방식<br>
                    Go-Back-N ARQ의 ACK세그먼트가<br> 
                    누적 확인 응답이라면,<br>
                    Selective Repeat ARQ의<br> 
                    ACK세그먼트는 개별 확인 응답<br>
                    (Selective Acknowledgment)<br>
                    오늘날의 대부분의 호스트는<br> 
                    Selective Repeat ARQ를<br> 
                    사용하지 않을 경우<br>
                    Go-Back-N ARQ로 동작</li>
                <li>파이프라이닝 기반이더라도<br> 
                    무한으로 데이터를 보낼 수는 없다</li>
                <li>정상 동작하려면 수신 호스트가<br> 
                    한번에 얼마나 바다 처리할 수<br> 
                    있는지 반드시 고려해야함</li>
                <li>호스트가 한번에 받아서 처리할 수<br> 
                    있는 세그먼트의 양에는 한계가<br> 
                    있기때문,한번에 n개의바이트를<br> 
                    받아서 처리할 수 있다면<br> 
                    n바이트만 보내야함 </li>
            <h4>TCP의 흐름 제어</h4>    
                <li>송신 호스트가 수신 호스트의 처리<br> 
                    속도를 고려하며 송수신 속도를<br> 
                    균일하게 유지하는 기능<br>
                    Stop-and-Wait ARQ를 사용하면<br> 
                    별도의 흐름 제어가 필요하지 않음<br>
                    파이프라이닝 기반의 ARQ에서는 필요</li>
            <h4>슬라이딩 윈도우:TCP흐름 제어 기법</h4>    
                <li>윈도우-송신호스트가 파이프라이닝<br> 
                    할 수 있는 최대량, 즉 윈도우 크기 만큼<br>
                    확인 응답을 받지 않고도<br> 
                    한번에 전송 가능하다는 의미</li>
                <li>수신 호스트로부터 첫 번째 세그먼트에<br> 
                    대한ACK세그먼트를 받았다면<br>
                    윈도우는 오른쪽으로 한칸 이동</li>
                <li>송신 측의 윈도우도 있다<br>
                    수신 호스트는 TCP헤더(윈도우필드)<br>
                    를 통해 송신 호스트에게 자신이<br> 받을
                    데이터의 양을 알려줌<br>
                    송신 윈도우:헤더로 전달 받은<br> 
                    수신 윈도우 토대로 연산</li>
            <h4>혼잡(congestion)</h4>
                <li>많은 트래픽으로 인해 패킷의<br> 
                    처리 속도가 늦어지거나 유실될<br> 
                    우려가 있는 네트워크 상황</li>
                <li>TCP의 혼잡 제어:<br>
                    송신 호스트가 혼잡한 정도에 맞춰<br> 
                    유동적으로 전송량을 조절하는 기능<br>
                    흐름 제어의 주체가 수신 호스트라면<br> 
                    혼잡 제어의 주체는 송신 호스트</li>
                <li>혼잡 윈도우-혼잡 없이 전송할 수<br> 
                    있을 법한 데이터양<br>
                    혼잡 윈도우가 크면 한번 에 전송할<br> 
                    수 있는 세그먼트 수가 많음<br>
                    혼잡 윈도우가 작으면<br>
                    (네트워크가 혼잡한 상황)한번에<br>
                    전송할 수 있는 세그먼트 수가 적음</li>
                <li>수신 윈도우는 수신 호스트가<br> 
                    헤더로 알려줌</li>
                <li>혼잡 윈도우는 송신 호스트가 알아서<br>
                    직접 계산해서 알아내야 함</li>
            <h4>TCP의 혼잡 제어 알고리즘</h4>    
                <li>혼잡 제어를 수행하는 일련의 방법</li>
                <li>가장 기본적인 알고리즘인<br> 
                    AIMD(Additive Increase/<br>
                    Multiplicative Decease)</li>
                <li>합으로 증가, 곱으로 감소</li>
                <li>혼잡이 감지되지 않는다면 혼잡<br> 
                    윈도우를 RTT(Round Trip Time)<br>
                    마다 1씩 선형적으로 증가</li>
                <li>혼잡이 감지되면 혼잡 윈도우를<br> 
                    절반으로 떨어뜨리는 동작을 반복</li>
                <li>RTT:메시지를 전송한뒤 그에 대한<br>
                    답변을 받는데 까지 걸리는 시간</li>
                <li>$ ping -c www.google.com</li>
            <h4>느린 시작(slow start) 알고리즘</h4>    
                <li>혼잡 윈도우를 1부터 시작해<br> 
                    문제없이 수신된 ACk세그먼트<br> 
                    하나당 1씩 증가시키는 방식</li>
                <li>혼잡 윈도우를 RTT마다 2배씩<br> 
                    지수적으로 증가<br>
                    초기 전송 속도 빠른 확보</li>
                <li>느린 시작 임계치(threshold)</li>
                <li>혼잡 윈도우 값이 계속 증가하다가<br>
                    혼잡 윈도우 크기가 느린 시작<br> 임계치
                    이상이 되거나,타임아웃 되거나<br>
                    세번의 중복 된 ACK세그먼트를<br> 
                    수신하면 다음 세가지 방법중 하나 선택</li>
                <li>타임아웃 발생:혼잡 윈도우 값을 1로<br>
                    느린 시작 임계치를 혼잡이 감지<br>
                    되었을 시점의 혼잡 윈도우 값의<br> 
                    절반으로 초기화 한뒤 느리 시작 재개</li>
                <li>혼잡윈도우>=느린 시작 임계치:<br>
                    느린 시작 종료,혼잡회피 수행</li>
                <li>세 번의 중복 ACK발생:<br>
                    (빠른 재선송후)빠른 회복 수행</li>
            <h4>혼잡 회피 알고리즘</h4>    
                <li>RTT마다 혼잡 윈도우를 1MSS씩<br>
                    증가시키는 알고리즘</li>
                <li>혼잡 윈도우 크기 선형적으로 증가</li>
                <li>워워워:느린 시작 임계치를 넘어서면<br>
                    혼잡 여지가 있으니 조심해서<br> 
                    혼잡 윈도우 증가하기</li>
            <h4>빠른 회복 알고리즘</h4>    
                <li>세 번의 중복 세그먼트 수신 VS<br>
                    타임 아웃 뭐가 더 심각할까?</li>
                <li>보통 타임 아웃이 더 심각함</li>
                <li>세번의 중복된ACK세그먼트 수신:<br>
                    빠른재전송+빠른회복 알고리즘</li>
                <li>빠른 전송률 회복을 위해<br> 
                    느린 시작은 건너뛰고 혼잡<br> 
                    회피를 수행하는 알고리즘</li>
                <li>단,빠른 히ㅗ복 도중이라도<br> 
                    타임아웃이 발생하면 다시 느린<br> 
                    시작을 수행</li>
            <h4>ECN:명시적 혼잡 알림</h4>    
                <li>중간노드의 도움으로 혼잡을 제어</li>
                <li>혼잡 감지,혼잡윈도우계산,재전송:<br>
                    오로지 송신 호스트의 몫</li>
                <li>혼잡을 피하기 위해 네트워크 중간<br>
                    장치(주로 라우터)의 도움을 받는 방법</li>
                <li>호스트가 ECN을 지원할 경우:<br>
                    TCP/IP헤더에 ECN관련 비트 추가</li>
                <li>ECN을 통한 혼잡 제어</li>
                <li>송신 호스트만 혼잡제어를 수행할<br> 
                    경우 문제가 발생한 이후에<br> 
                    비로소 혼잡 제어</li>
                <li>ECN을 이용하면 수신 호스트의 ACK<br>
                    세그먼터를 통해 더빠르게 혼잡을 감지</li>        
            <h4><a href="page_network7.html"> Application-layer1 </a></h4>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>