<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Part4</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
        
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp" alt=""/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
            
    </header>
    
    <section class="content">
        
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript2.html"> JavaScript</a></li>
            <li><a href="page_javascript.html"> JavaScript-with Web </a></li>
            <li><a href="page_javascript3.html"> JavaScript-with Nodejs </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_php.html"> PHP </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_database.html"> Database </a></li>
            <li><a href="page_datastr.html"> Data-Structure </a></li>
            <li><a href="page_cs1.html"> CS知識1 </a></li>
            <li><a href="page_cs2.html"> CS知識2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_os4.html"> OS Part4 </a></li>
            <li><a href="page_network.html"> Network-OSI model </a></li>
            <li><a href="page_network2.html"> Physical-Data-layer1 </a></li>
            <li><a href="page_network3.html"> Physical-Data-layer2 </a></li>
            <li><a href="page_network4.html"> Network-layer1 </a></li>
            <li><a href="page_network5.html"> Network-layer2 </a></li>
            <li><a href="page_network6.html"> Transport-layer </a></li>
            <li><a href="page_network7.html"> Application-layer1 </a></li>
            <li><a href="page_network8.html"> Application-layer2 </a></li>
            <li><a href="page_network9.html"> Application-layer3 </a></li>
            <li><a href="page_network10.html"> Application-layer4 </a></li>
            <li><a href="page_network11.html"> Application-layer5 </a></li>
        </ol>
    </nav>
    
         <main>
            
            <h2>OS part3</h2>
            <ul>
            <h4>연속 메모리 할당</h4>
                <li>프로세스에 연속으로 메모리 공간 할당</li>
            <h4>스와핑</h4>    
                <li>현재 사용되지 않는 프로세스들을<br>
                    보조기억장치의 일부 영역으로<br>
                    쫒아내고 그렇개 생긴 빈 공간에<br>
                    새 프로세스를 적재</li>
                <li>스왑인,스왑영역,스왑 아웃</li>
                <li>스왑영역:보조기억장치안</li>
                <li>프로세스들이 요구하는 <br>
                    메모리공간 크기가 실제<br>
                    메모리 크기보다 커도 실행가능</li>
            <h4>스왑영역 크기 확인하기</h4>    
                <li>free,top</li>
            <h4>메모리 할당</h4>    
                <li>프로세스는 메모리의빈 공간에<br> 할당되아야 한다</li>
                <li>빈 공간이 여러개 라면?</li>
                <li>최초 적합,최적 적합,최악 적합</li>
                <li>최초 적합(first-fit):<br>
                    빈 공간을 검색하다 적재할<br>
                    수 있는 공간을 발견하면<br>
                    그 공간에 프로세스를 배치</li>
                <li>검색 최소화,빠른 할당</li>
                <li>최적 적합(best-fit):<br>
                    빈 공간을 모두 검색후,<br>
                    적재 가능한 가장 작은 공간에 할당</li>
                <li>최악 적합(worst-fit):<br>
                    빈 공간을 모두 검색후,<br>
                    적재 가능한 가장큰 공간에 할당</li>
            <h4>외부 단편화</h4>
                <li>사실,프로세스를 연속적으로<br>
                    메모리에 할당하는 방식은<br>
                    메모리를 효율적으로<br> 
                    사용하는 방법이 아니다</li>
                <li>외부 단편화(external fragmentation)<br>
                    라는 문제가 발생하기 때문</li>
                <li>프로세스들이 실행되고 종료되고<br>
                    반복하며 메모리 사이 사이에<br>
                    빈 공간이 발생</li>
                <li>프로세스를 할당하기 어려울<br>
                    만큼 작은 메모리 공간들로 인해<br>
                    메모리가 낭비되는 현상</li>
            <h4>외부 단편화 해결</h4>
                <li>메모리 압축(compaction)</li>
                <li>흩어져 있는 빈공간들을 모음</li>
                <li>프로세스를 적당히 재배치시켜<br>
                    흩어져 있는 작은 빈공간들을<br>
                    하나의 큰 빈 공간으로 만드는 방법</li>
            <h4>연속 메모리 할당의 문제점</h4>
                <li>외부 단편화</li>
                <li>물리 메모리보다 큰 프로세스 실행불가</li>
            <h4>가상 메모리 관리 기법-페이징</h4>    
                <li>가상 메모리</li>
                <li>실행하고자 하는 프로그램을<br>
                    일부만 메모리에 적재하여 실제 물리<br>
                    메모리 크기보다 더 큰 프로세스를<br>
                    실행하게 할 수 있는 기술</li>
                <li>페이징,세그멘테이션등</li>
                <li>외부 단편화의 근본적인 원인</li>
                <li>각기 다른 크기의 프로세스가 메모리에<br>
                    연속적으로 할당되었기 때문</li>
                <li>모든 프로세스의 크가가 같다면<br>
                    외부 단편화는 발생하지 않는다</li>
            <h4>페이징이란</h4>    
                <li>프로세스를 일정 크기로 자르고<br>
                    이를 메모리에 불연속적으로<br>
                    할당할 수 있다면?</li>
                <li>프로세스의 논리 주소 공간을<br>
                    페이지라는 일정 단위로 자르고<br>
                    메모리의 물리주소 공간을 프레임이라는<br>
                    페이지와 동일한 일정한 단위로 자른뒤<br>
                    페이지를 프레임에 할당하는<br>
                    가상 메모리 관리 기법</li>
                <li>페이징에서의 스와핑</li>
                <li>페이지 인,페이지 아웃</li>
                <li>프로세스를 실행하기 위해<br>
                    모든 페이지가 적재될 필요 없다</li>
                <li>즉,물리 메모리보다 큰 프로세스도<br> 
                    실행 될 수 있다</li>
            <h4>페이지 테이블</h4> 
                <li>(실제 메모리 내의 주소인)물리주소에<br>
                    불 연속적으로 배치되더라도</li>
                <li>(CPU가 바라보는 주소)논리 주소에는<br>
                    연속적으로 배치되도록 하는 방법</li>
                <li>페이지 번호와 프레임번호를<br>
                    짝지어 주는 일종의 이정표</li>
                <li>프로세스마다 페이지 테이블이 있다</li>
                <li>물리적으로는 분산되어 저장되어<br> 
                    있더라도 CPU입장에서 바라본<br> 
                    논리 주소는 연속적으로 보임</li>
                <li>CPU는 그저 논리 주소를<br>
                    순차적을 싱행하면 될뿐</li>
            <h4>내부 단편화</h4>    
                <li>페이지 10KB,프로세스 108KB?</li>
                <li>2KB 내부 단편화</li>
                <li>하나의 페이지 크기보다<br>
                    작은크기로 발생</li>
            <h4>PTBR</h4>    
                <li>페이지 테이블 베이스 레지스터</li>
                <li>각 프로세스의 페이지 테이블이<br>
                    적재된 주소를 가르킨다</li>
                <li>프로세스마다 페이지 테이블 존재</li>
                <li>하지만 메모리 접근 시간 두배로</li>
                <li>페이지 테이블 참조하기 위해 한번</li>
                <li>페이지 참조하기 위해 한번</li>
            <h4>TLB</h4>    
                <li>CPU곁에 페이지 테이블의 캐시 메모리</li>
                <li>페이지 테이블의 일부를 가져와 저장</li>
                <li>TLB히트:메모리 접근 한번</li>
                <li>TLB미스:메모리 접근 두번</li>
            <h4>페이징에서의 주소 변환</h4>    
                <li>특정 주소에 접근하고자 할때<br>
                    필요한 정보는?</li>
                <li>어떤페이지/프레임에 접근하고 싶은지</li>
                <li>접근하려는 주소가 그 페이지<br>
                    혹은 프레임으로 부터<br>
                    얼마나 떨어져 있는지</li>
                <li>페이징 시스템에서의 논리 주소</li>
                <li>페이지 번호,변위=></li>
                <li>페이지 테이블=></li>
                <li>프레임 번호, 변위</li>
                <li>두개의 변위는 같다</li>
                <li>페이지 테이블의 각각의 행:<br>
                    페이지 테이블 엔트리(PTE)</li>
                <li>페이지 번호</li>
                <li>프레임 번호</li>
                <li>유효 비트:현재 해당 페이지에<br>
                    접근 가능한지 여부</li>
                <li>유효 비트 0인 페이지에 접근하면
                    <br>페이지 폴트(page fault)라는<br>
                    인터럽트 발생</li>
                <li>CPU는 기존의 작업내역 백업</li>
                <li>페이지 폴트 처리 루틴 실행</li>
                <li>페이지 처리 루틴은 원하는 페이지를<br>
                    메모리로 가져온 뒤<br>
                    유효 비트를 1로 변경</li>
                <li>페이지 폴트를 처리했다면 이제<br>
                    CPU는 해당 페이지에 접근할 수 있다</li>
                <li>보호비트:페이지 보호 기능을 위해 존재</li>
                <li>참조비트:CPU가 이 페이지에 <br>
                    접근한 적이 있는지 여부</li>
                <li>수정비트(dirty bit):CPU가 이<br>
                    페이지에 데이터를 쓴적이 있는지 여부</li>
                <li>수정비트의 존재 이유</li>
                <li>수정된 페이지는 스왑 아웃될 때 보조<br>
                    기억장치에도 쓰기 작업을 거쳐야 한다</li>
            <h4>페이지 교체와 프레임 할당</h4>    
                <li>요구 페이징:
                    <br>요구되는 페이지만 적재하는 기법</li>
                <li>페이지 교체 알고리즘</li>
                <li>요구 페이징 기법으로 페이지들을 적재<br>
                    하다보면 언젠간 메모리가<br> 가득 차게 된다</li>
                <li>이때 어떤 페이지를 내보낼까</li>
                <li>이를 결정하는 방법(알고리즘)이<br></li>
                <li>페이지 교체 알고리즘</li>
                <li>무엇이 좋은 페이지 교체 알고리즘?</li>
                <li>페이지 폴트가 적은 알고리즘</li>
                <li>페이지 폴트가 발생하면 보조기억<br>
                    장치에 접근해야 해서 성능 저하</li>
                <li>페이지 폴트의 횟수는 어떻게 아나</li>
                <li>페이지 참조열:CPU가 참조하는<br>
                    페이지들 중 연속된 페이지를<br>
                    생략한 페이지열</li>
            <h4>FIFO 페이지 교체 알고리즘</h4>    
                <li>가장 단순한 방식</li>
                <li>메모리에 가장 먼저 올라온<br>
                    페이지부터 내쫓는 방식</li>
                <li>실행 내내 사용되야할 페이지를<br></li>
                <li>내쫓을 수 도 있다</li>
                <li>2차 기회 페이지 교체 알고리즘</li>
                <li>참조비트1:CPU가 한번 참조한 적 있음</li>
                <li>참조비트0으로 바꾸고 다시 기회줌</li>
                <li>참조비트0:CPU가 참조한적 없음</li>
                <li>오래 머물렀는대 참조가0이니 내쫒기</li>
            <h4>최적 페이지 교체 알고리즘</h4>    
                <li>CPU에 의해 참조되는 횟수를 고려</li>
                <li>메모리에 오래 남아야할 페이지는<br>
                    자주 사욜될 페이지</li>
                <li>메모리에 없어도 될 페이지는<br>
                    오랫동안 사용되지 않을 페이지</li>
                <li>앞으로 사용 빈도가 가장 낮은<br>
                    페이지를 교체하는 알고리즘</li>
                <li>실제 구현이 어렵다</li>
            <h4>LRU(Least-Recently_Used)<br>
                페이지 교체 알고리즘</h4>    
                <li>가장 오래 사용되지 않은 페이지 교체</li>
                <h4><a href="page_os4.html"> OS Part4 </a></h4>
            </ul>
                
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>