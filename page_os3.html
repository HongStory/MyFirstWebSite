<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS part3</title>
    <link rel="stylesheet" href="light-mode.css" id="css-link">
</head>
<body>
    <div class="container">
    <header>
        <div id = "control">
            <input type="button" value="DarkModOn" onclick="changeMode();"/>
        </div>
        <img src="logo.webp"/>
        <h1><a href ="index.html">My First Web Site!</h1>
            
    </header>
    
    <section class="content">
    <nav>
        <ol>
            <li><a href="page_html.html"> HTML </a></li>
            <li><a href="page_css.html"> CSS </a></li>
            <li><a href="page_javascript.html"> JavaScript </a></li>
            <li><a href="page_react.html"> React </a></li>
            <li><a href="page_nextjs.html"> Nextjs </a></li>
            <li><a href="page_nodejs.html"> Nodejs </a></li>
            <li><a href="page_mysql.html"> Mysql </a></li>
            <li><a href="page_git.html"> Git </a></li>
            <li><a href="page_pm.html"> Package-Manager </a></li>
            <li><a href="page_cs1.html"> 컴퓨터구조 </a></li>
            <li><a href="page_cs2.html"> 구조파트2 </a></li>
            <li><a href="page_os.html"> OS Part1</a></li>
            <li><a href="page_os2.html"> OS Part2 </a></li>
            <li><a href="page_os3.html"> OS Part3 </a></li>
            <li><a href="page_network.html"> Network </a></li>
        </ol>
    </nav>
    
        <main>
            <h2>OS part3</h2>
            <ul>
            <h4>연속 메모리 할당</h4>
                <li>프로세스에 연속으로 메모리 공간 할당</li>
            <h4>스와핑</h4>    
                <li>현재 사용되지 않는 프로세스들을<br>
                    보조기억장치의 일부 영역으로 쫒아내고<br>
                    그렇개 생긴 빈 공간에 새 프로세스를 적재</li>
                <li>스왑인,스왑영역,스왑 아웃</li>
                <li>스왑영역:보조기억장치안</li>
                <li>프로세스들이 요구하는 <br>
                    메모리공간 크기가 실제<br>
                    메모리 크기보다 커도 실행가능</li>
            <h4>스왑영역 크기 확인하기</h4>    
                <li>free,top</li>
            <h4>메모리 할당</h4>    
                <li>프로세스는 메모리의빈 공간에<br> 할당되아야 한다</li>
                <li>빈 공간이 여러개 라면?</li>
                <li>최초 적합,최적 적합,최악 적합</li>
                <li>최초 적합(first-fit):<br>
                    빈 공간을 검색하다 적재할<br>
                    수 있는 공간을 발견하면<br>
                    그 공간에 프로세스를 배치</li>
                <li>검색 최소화,빠른 할당</li>
                <li>최적 적합(best-fit):<br>
                    빈 공간을 모두 검색후,<br>
                    적재 가능한 가장 작은 공간에 할당</li>
                <li>최악 적합(worst-fit):<br>
                    빈 공간을 모두 검색후,<br>
                    적재 가능한 가장큰 공간에 할당</li>
            <h4>외부 단편화</h4>
                <li>사실,프로세스를 연속적으로<br>
                    메모리에 할당하는 방식은<br>
                    메모리를 효율적으로<br> 
                    사용하는 방법이 아니다</li>
                <li>외부 단편화(external fragmentation)<br>
                    라는 문제가 발생하기 때문</li>
                <li>프로세스들이 실행되고 종료되고<br>
                    반복하며 메모리 사이 사이에<br>
                    빈 공간이 발생</li>
                <li>프로세스를 할당하기 어려울<br>
                    만큼 작은 메모리 공간들로 인해<br>
                    메모리가 낭비되는 현상</li>
            <h4>외부 단편화 해결</h4>
                <li>메모리 압축(compaction)</li>
                <li>흩어져 있는 빈공간들을 모음</li>
                <li>프로세스를 적당히 재배치시켜<br>
                    흩어져 있는 작은 빈공간들을<br>
                    하나의 큰 빈 공간으로 만드는 방법</li>
            <h4>연속 메모리 할당의 문제점</h4>
                <li>외부 단편화</li>
                <li>물리 메모리보다 큰 프로세스 실행불가</li>
            <h4>가상 메모리 관리 기법-페이징</h4>    
                <li>가상 메모리</li>
                <li>실행하고자 하는 프로그램을<br>
                    일부만 메모리에 적재하여 실제 물리<br>
                    메모리 크기보다 더 큰 프로세스를<br>
                    실행하게 할 수 있는 기술</li>
                <li>페이징,세그멘테이션등</li>
                <li>외부 단편화의 근본적인 원인</li>
                <li>각기 다른 크기의 프로세스가 메모리에<br>
                    연속적으로 할당되었기 때문</li>
                <li>모든 프로세스의 크가가 같다면<br>
                    외부 단편화는 발생하지 않는다</li>
            <h4>페이징이란</h4>    
                <li>프로세스를 일정 크기로 자르고<br>
                    이를 메모리에 불연속적으로<br>
                    할당할 수 있다면?</li>
                <li>프로세스의 논리 주소 공간을<br>
                    페이지라는 일정 단위로 자르고<br>
                    메모리의 물리주소 공간을 프레임이라는<br>
                    페이지와 동일한 일정한 단위로 자른뒤<br>
                    페이지를 프레임에 할당하는<br>
                    가상 메모리 관리 기법</li>
                <li>페이징에서의 스와핑</li>
                <li>페이지 인,페이지 아웃</li>
                <li>프로세스를 실행하기 위해<br>
                    모든 페이지가 적재될 필요 없다</li>
                <li>즉,물리 메모리보다 큰 프로세스도<br> 
                    실행 될 수 있다</li>
            <h4>페이지 테이블</h4> 
                <li>(실제 메모리 내의 주소인)물리주소에<br>
                    불 연속적으로 배치되더라도</li>
                <li>(CPU가 바라보는 주소)논리 주소에는<br>
                    연속적으로 배치되도록 하는 방법</li>
                <li>페이지 번호와 프레임번호를<br>
                    짝지어 주는 일종의 이정표</li>
                <li>프로세스마다 페이지 테이블이 있다</li>
                <li>물리적으로는 분산되어 저장되어<br> 
                    있더라도 CPU입장에서 바라본<br> 
                    논리 주소는 연속적으로 보임</li>
                <li>CPU는 그저 논리 주소를<br>
                    순차적을 싱행하면 될뿐</li>
            <h4>내부 단편화</h4>    
                <li>페이지 10KB,프로세스 108KB?</li>
                <li>2KB 내부 단편화</li>
                <li>하나의 페이지 크기보다 작은크기로 발생</li>
            <h4>PTBR</h4>    
                <li>페이지 테이블 베이스 레지스터</li>
                <li>각 프로세스의 페이지 테이블이<br>
                    적재된 주소를 가르킨다</li>
                <li>프로세스마다 페이지 테이블 존재</li>
                <li>하지만 메모리 접근 시간 두배로</li>
                <li>페이지 테이블 참조하기 위해 한번</li>
                <li>페이지 참조하기 위해 한번</li>
            <h4>TLB</h4>    
                <li>CPU곁에 페이지 테이블의 캐시 메모리</li>
                <li>페이지 테이블의 일부를 가져와 저장</li>
                <li>TLB히트:메모리 접근 한번</li>
                <li>TLB미스:메모리 접근 두번</li>
            <h4>페이징에서의 주소 변환</h4>    
                <li>특정 주소에 접근하고자 할때<br>
                    필요한 정보는?</li>
                <li>어떤페이지/프레임에 접근하고 싶은지</li>
                <li>접근하려는 주소가 그 페이지<br>
                    혹은 프레임으로 부터<br>
                    얼마나 떨어져 있는지</li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
            
        </main>
        
        <!-- <aside>AD</aside> -->
        </section>
        <footer>
            <a href="https://opentutorials.org/course/1">멘토 사이트</a>
            <input id = "rollUp" type="button" value="UpScroll" onclick="scroll();"/>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>